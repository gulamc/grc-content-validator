"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/controls/score/route";
exports.ids = ["app/api/controls/score/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcontrols%2Fscore%2Froute&page=%2Fapi%2Fcontrols%2Fscore%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcontrols%2Fscore%2Froute.ts&appDir=%2Fworkspaces%2Fgrc-content-validator%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fworkspaces%2Fgrc-content-validator&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcontrols%2Fscore%2Froute&page=%2Fapi%2Fcontrols%2Fscore%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcontrols%2Fscore%2Froute.ts&appDir=%2Fworkspaces%2Fgrc-content-validator%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fworkspaces%2Fgrc-content-validator&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _workspaces_grc_content_validator_app_api_controls_score_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/controls/score/route.ts */ \"(rsc)/./app/api/controls/score/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/controls/score/route\",\n        pathname: \"/api/controls/score\",\n        filename: \"route\",\n        bundlePath: \"app/api/controls/score/route\"\n    },\n    resolvedPagePath: \"/workspaces/grc-content-validator/app/api/controls/score/route.ts\",\n    nextConfigOutput,\n    userland: _workspaces_grc_content_validator_app_api_controls_score_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/controls/score/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZjb250cm9scyUyRnNjb3JlJTJGcm91dGUmcGFnZT0lMkZhcGklMkZjb250cm9scyUyRnNjb3JlJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY29udHJvbHMlMkZzY29yZSUyRnJvdXRlLnRzJmFwcERpcj0lMkZ3b3Jrc3BhY2VzJTJGZ3JjLWNvbnRlbnQtdmFsaWRhdG9yJTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZ3b3Jrc3BhY2VzJTJGZ3JjLWNvbnRlbnQtdmFsaWRhdG9yJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNpQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2RlYWRsaW5lcy1kZW1vLXVpLz8wODhhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi93b3Jrc3BhY2VzL2dyYy1jb250ZW50LXZhbGlkYXRvci9hcHAvYXBpL2NvbnRyb2xzL3Njb3JlL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jb250cm9scy9zY29yZS9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2NvbnRyb2xzL3Njb3JlXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9jb250cm9scy9zY29yZS9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi93b3Jrc3BhY2VzL2dyYy1jb250ZW50LXZhbGlkYXRvci9hcHAvYXBpL2NvbnRyb2xzL3Njb3JlL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9jb250cm9scy9zY29yZS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcontrols%2Fscore%2Froute&page=%2Fapi%2Fcontrols%2Fscore%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcontrols%2Fscore%2Froute.ts&appDir=%2Fworkspaces%2Fgrc-content-validator%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fworkspaces%2Fgrc-content-validator&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/controls/score/route.ts":
/*!*****************************************!*\
  !*** ./app/api/controls/score/route.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _scorer_controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/scorer/controls */ \"(rsc)/./scorer/controls.ts\");\n// app/api/control/score/route.ts\n\n\nasync function POST(req) {\n    try {\n        const body = await req.json();\n        const input = {\n            id: body.id || \"\",\n            name: body.name || \"\",\n            description: body.description || \"\",\n            guidance: body.guidance || \"\",\n            framework: body.framework || \"\"\n        };\n        const result = (0,_scorer_controls__WEBPACK_IMPORTED_MODULE_1__.scoreControl)(input);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(result);\n    } catch (error) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error.message || \"Scoring failed\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2NvbnRyb2xzL3Njb3JlL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGlDQUFpQztBQUN1QjtBQUNPO0FBRXhELGVBQWVFLEtBQUtDLEdBQWdCO0lBQ3pDLElBQUk7UUFDRixNQUFNQyxPQUFPLE1BQU1ELElBQUlFLElBQUk7UUFFM0IsTUFBTUMsUUFBc0I7WUFDMUJDLElBQUlILEtBQUtHLEVBQUUsSUFBSTtZQUNmQyxNQUFNSixLQUFLSSxJQUFJLElBQUk7WUFDbkJDLGFBQWFMLEtBQUtLLFdBQVcsSUFBSTtZQUNqQ0MsVUFBVU4sS0FBS00sUUFBUSxJQUFJO1lBQzNCQyxXQUFXUCxLQUFLTyxTQUFTLElBQUk7UUFDL0I7UUFFQSxNQUFNQyxTQUFTWCw4REFBWUEsQ0FBQ0s7UUFFNUIsT0FBT04scURBQVlBLENBQUNLLElBQUksQ0FBQ087SUFDM0IsRUFBRSxPQUFPQyxPQUFZO1FBQ25CLE9BQU9iLHFEQUFZQSxDQUFDSyxJQUFJLENBQ3RCO1lBQUVRLE9BQU9BLE1BQU1DLE9BQU8sSUFBSTtRQUFpQixHQUMzQztZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2RlYWRsaW5lcy1kZW1vLXVpLy4vYXBwL2FwaS9jb250cm9scy9zY29yZS9yb3V0ZS50cz80NWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFwcC9hcGkvY29udHJvbC9zY29yZS9yb3V0ZS50c1xuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L3NlcnZlclwiO1xuaW1wb3J0IHsgc2NvcmVDb250cm9sLCBDb250cm9sSW5wdXQgfSBmcm9tIFwiQC9zY29yZXIvY29udHJvbHNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxOiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXEuanNvbigpO1xuICAgIFxuICAgIGNvbnN0IGlucHV0OiBDb250cm9sSW5wdXQgPSB7XG4gICAgICBpZDogYm9keS5pZCB8fCBcIlwiLFxuICAgICAgbmFtZTogYm9keS5uYW1lIHx8IFwiXCIsXG4gICAgICBkZXNjcmlwdGlvbjogYm9keS5kZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgZ3VpZGFuY2U6IGJvZHkuZ3VpZGFuY2UgfHwgXCJcIixcbiAgICAgIGZyYW1ld29yazogYm9keS5mcmFtZXdvcmsgfHwgXCJcIlxuICAgIH07XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gc2NvcmVDb250cm9sKGlucHV0KTtcbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgXCJTY29yaW5nIGZhaWxlZFwiIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsInNjb3JlQ29udHJvbCIsIlBPU1QiLCJyZXEiLCJib2R5IiwianNvbiIsImlucHV0IiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJndWlkYW5jZSIsImZyYW1ld29yayIsInJlc3VsdCIsImVycm9yIiwibWVzc2FnZSIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/controls/score/route.ts\n");

/***/ }),

/***/ "(rsc)/./scorer/controls.ts":
/*!****************************!*\
  !*** ./scorer/controls.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scoreControl: () => (/* binding */ scoreControl)\n/* harmony export */ });\n/* harmony import */ var _specs_controls_standard_v1_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../specs/controls_standard.v1.json */ \"(rsc)/./specs/controls_standard.v1.json\");\n// scorer/controls.ts - Enhanced Control Scoring aligned with GRC Content Standard\n\nconst spec = _specs_controls_standard_v1_json__WEBPACK_IMPORTED_MODULE_0__;\n// ========== UTILITIES ==========\nfunction dedupe(arr) {\n    if (!arr) return arr;\n    return Array.from(new Set(arr.filter(Boolean)));\n}\nfunction looksStructured(text) {\n    return /(^|\\n)\\s*(?:[-*•]|\\d+[.)]|[a-z][.)])\\s+/m.test(text);\n}\nfunction countSentences(text) {\n    return text.split(/[.!?]+/).filter((s)=>s.trim().length > 0).length;\n}\nfunction extractSteps(text) {\n    const steps = [];\n    // Method 1: Extract steps on separate lines\n    const lines = text.split(\"\\n\");\n    for (const line of lines){\n        if (/^\\s*(?:[-*•]|\\d+[.)]|[a-z][.)])\\s+(.+)/.test(line)) {\n            steps.push(line.trim());\n        }\n    }\n    // Method 2: If no line-based steps, look for inline numbered steps\n    if (steps.length === 0) {\n        // Find ALL \"number. text\" patterns using global regex\n        const pattern = /(\\d+[.)])\\s*([^;]+)/g;\n        let match;\n        while((match = pattern.exec(text)) !== null){\n            const stepText = match[2].trim();\n            if (stepText.length > 5) {\n                steps.push(stepText);\n            }\n        }\n    }\n    return steps;\n}\n// ========== REGEX PATTERNS ==========\nconst MODAL_VERBS = /\\b(should|could|may|might|must|shall|ensure|ensures|ensured)\\b/i;\nconst VENDOR_NAMES = /\\b(aws|azure|gcp|google\\s+cloud|okta|servicenow|cisco|palo\\s*alto|fortinet|splunk|datadog|salesforce|snowflake|crowdstrike|microsoft|oracle|ibm|sap)\\b/i;\nconst JARGON_WORDS = /\\b(utilize|leverage|synergy|holistic|best[-\\s]?of[-\\s]?breed|operationalize)\\b/i;\nconst ROLE_SPECIFIC = /\\b(it|security|engineering|devops|audit|privacy|hr|legal|finance)\\s+(team|dept|department|administrator|manager)\\b/i;\nconst DIRECTIVE_VERBS = /^\\s*(configure|install|deploy|enable|set\\s*up|create|develop|implement|establish|define)\\b/i;\nconst PRESENT_TENSE_INDICATORS = /\\b(is|are|has|have|exists?|remains?|includes?|contains?|provides?|ensures?|maintains?|supports?|performs?|conducts?)\\b/i;\nconst PASSIVE_VOICE_INDICATORS = /\\b(is|are|be|being|been)\\s+[a-z]+ed\\b/i;\nconst ACTION_WORDS = /\\b(protection|detection|monitoring|review|assessment|management|implementation|configuration|establishment|maintenance|planning|testing|auditing|tracking|reporting|training|enforcement|validation|verification|analysis)\\b/i;\n// ========== ID QUALITY CHECKS (15% weight) ==========\nfunction evalIdStructured(id) {\n    const hasSeparator = id.includes(\".\");\n    const points = hasSeparator ? 20 : 12;\n    const violations = hasSeparator ? undefined : [\n        \"Use structured format with separator (e.g., GDPR.1.1 or NIST.AC.1)\"\n    ];\n    return {\n        id: \"id.structured\",\n        label: \"Structured format (prefix.section.number)\",\n        points,\n        max: 20,\n        status: points === 20 ? \"PASS\" : \"WARN\",\n        notes: violations?.[0],\n        violations\n    };\n}\nfunction evalIdLength(id) {\n    const len = id.length;\n    const withinBounds = len > 0 && len <= (spec.rules.id.max_length || 24);\n    const points = withinBounds ? 15 : len > 24 ? 8 : 0;\n    const violations = [];\n    if (!withinBounds) {\n        if (len === 0) violations.push(\"ID cannot be empty\");\n        else violations.push(`ID too long (${len} chars). Keep under ${spec.rules.id.max_length || 24} characters.`);\n    }\n    return {\n        id: \"id.length\",\n        label: \"Appropriate length\",\n        points,\n        max: 15,\n        status: points === 15 ? \"PASS\" : points >= 10 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? violations : undefined\n    };\n}\nfunction evalIdUniqueness(id) {\n    // This is a placeholder - in real implementation would check against database\n    // For MVP, we just validate it's not obviously invalid\n    const hasContent = id.trim().length > 0;\n    return {\n        id: \"id.uniqueness\",\n        label: \"Uniqueness (assumed within framework)\",\n        points: hasContent ? 15 : 0,\n        max: 15,\n        status: hasContent ? \"PASS\" : \"FAIL\",\n        notes: hasContent ? \"Uniqueness validation requires database check\" : \"ID is empty\"\n    };\n}\n// ========== NAME QUALITY CHECKS (15% weight) ==========\nfunction evalNameConcise(name) {\n    const words = name.trim().split(/\\s+/).length;\n    const maxWords = spec.rules.name.concise_max_words || 12;\n    const withinBounds = words > 0 && words <= maxWords;\n    const points = withinBounds ? 25 : words > maxWords ? 15 : 0;\n    const violations = withinBounds ? undefined : words === 0 ? [\n        \"Name cannot be empty\"\n    ] : [\n        `Too verbose (${words} words). Keep under ${maxWords} words.`\n    ];\n    return {\n        id: \"name.concise\",\n        label: \"Concise (≤12 words)\",\n        points,\n        max: 25,\n        status: points === 25 ? \"PASS\" : points >= 15 ? \"WARN\" : \"FAIL\",\n        notes: violations?.[0],\n        violations\n    };\n}\nfunction evalNameActionOriented(name) {\n    const hasActionWord = ACTION_WORDS.test(name);\n    const isVague = /\\b(things|stuff|items|matters|issues)\\b/i.test(name);\n    let points = 25;\n    const violations = [];\n    if (!hasActionWord) {\n        points -= 8;\n        violations.push(\"Use action-oriented or specific language (e.g., 'Protection of...', 'Access Review Process')\");\n    }\n    if (isVague) {\n        points -= 5;\n        violations.push(\"Avoid vague terms. Be specific about what the control addresses.\");\n    }\n    return {\n        id: \"name.action_oriented\",\n        label: \"Action-oriented or specific language\",\n        points: Math.max(0, points),\n        max: 25,\n        status: points === 25 ? \"PASS\" : points >= 18 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalNamePurposeClarity(name) {\n    const tooShort = name.trim().split(/\\s+/).length < 2;\n    const tooGeneric = /^(security|compliance|controls?|management|system)$/i.test(name.trim());\n    let points = 25;\n    const violations = [];\n    if (tooShort) {\n        points -= 10;\n        violations.push(\"Name too short. Add context about the control's purpose.\");\n    }\n    if (tooGeneric) {\n        points -= 10;\n        violations.push(\"Name too generic. Specify what aspect is being controlled.\");\n    }\n    return {\n        id: \"name.purpose_clarity\",\n        label: \"Purpose clarity\",\n        points: Math.max(0, points),\n        max: 25,\n        status: points === 25 ? \"PASS\" : points >= 18 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalNameRoleNeutral(name) {\n    const hasRoleRef = ROLE_SPECIFIC.test(name);\n    const points = hasRoleRef ? 15 : 25;\n    const violations = hasRoleRef ? [\n        \"Avoid role-specific references in the name to ensure applicability across organizational structures\"\n    ] : undefined;\n    return {\n        id: \"name.role_neutral\",\n        label: \"Role-neutral\",\n        points,\n        max: 25,\n        status: points === 25 ? \"PASS\" : \"WARN\",\n        notes: violations?.[0],\n        violations\n    };\n}\n// ========== DESCRIPTION QUALITY CHECKS (30% weight) ==========\nfunction evalDescPresentTense(desc) {\n    const hasPresentTense = PRESENT_TENSE_INDICATORS.test(desc);\n    const hasFutureTense = /\\b(will|shall|going to)\\b/i.test(desc);\n    let points = 25;\n    const violations = [];\n    if (!hasPresentTense) {\n        points -= 10;\n        violations.push(\"Use present tense to convey the requirement is always applicable (e.g., 'is configured', 'are reviewed')\");\n    }\n    if (hasFutureTense) {\n        points -= 8;\n        violations.push(\"Avoid future tense ('will be'). Use present tense ('is').\");\n    }\n    return {\n        id: \"desc.present_tense\",\n        label: \"Present tense\",\n        points: Math.max(0, points),\n        max: 25,\n        status: points === 25 ? \"PASS\" : points >= 15 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalDescPassiveVoice(desc) {\n    const hasPassive = PASSIVE_VOICE_INDICATORS.test(desc);\n    const hasActiveDirective = DIRECTIVE_VERBS.test(desc) || ROLE_SPECIFIC.test(desc);\n    let points = 25;\n    const violations = [];\n    if (!hasPassive) {\n        points -= 8;\n        violations.push(\"Prefer passive voice for role-neutrality (e.g., 'Data is encrypted' not 'IT encrypts data')\");\n    }\n    if (hasActiveDirective) {\n        points -= 10;\n        violations.push(\"Avoid active voice directives. State the condition/outcome, not who performs it.\");\n    }\n    return {\n        id: \"desc.passive_voice\",\n        label: \"Passive voice (role-neutral)\",\n        points: Math.max(0, points),\n        max: 25,\n        status: points === 25 ? \"PASS\" : points >= 15 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalDescNoModalVerbs(desc) {\n    const hasModal = MODAL_VERBS.test(desc);\n    const points = hasModal ? 0 : 25;\n    const violations = hasModal ? [\n        \"Remove modal verbs (should/could/may/must/ensure). State the requirement definitively in present tense.\"\n    ] : undefined;\n    return {\n        id: \"desc.no_modal_verbs\",\n        label: \"No modal verbs (should/must/shall/ensure)\",\n        points,\n        max: 25,\n        status: points === 25 ? \"PASS\" : \"FAIL\",\n        notes: violations?.[0],\n        violations\n    };\n}\n// FIX 2: Better \"Single objective\" check - focus on multiple OUTCOMES, not sentences\nfunction evalDescSingleObjective(desc) {\n    // Check for multiple distinct outcomes (not just sentence count)\n    const hasMultipleAnds = (desc.match(/\\band\\b/gi) || []).length >= 3;\n    const hasOrClauses = /\\bor\\b/gi.test(desc);\n    // Check for multiple outcome statements (multiple \"is/are\" statements)\n    const outcomeStatements = desc.match(/\\b(is|are)\\s+[a-z]+ed\\b/gi) || [];\n    const multipleOutcomes = outcomeStatements.length > 2;\n    let points = 20;\n    const violations = [];\n    if (multipleOutcomes) {\n        points -= 10;\n        violations.push(`Multiple outcomes detected (${outcomeStatements.length} different states/results). Focus on one outcome per control.`);\n    }\n    if (hasMultipleAnds) {\n        points -= 5;\n        violations.push(\"Too many 'and' conjunctions. Consider if this is actually multiple controls.\");\n    }\n    if (hasOrClauses) {\n        points -= 5;\n        violations.push(\"'Or' clauses suggest ambiguity. Choose one clear objective.\");\n    }\n    return {\n        id: \"desc.single_objective\",\n        label: \"Single objective\",\n        points: Math.max(0, points),\n        max: 20,\n        status: points === 20 ? \"PASS\" : points >= 12 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalDescNoSteps(desc) {\n    // Check for ANY list markers anywhere in the description (not just at line start)\n    const hasListMarkers = /(?:[-*•]|\\d+[.)]|[a-z][.)])\\s+[A-Z]/.test(desc);\n    // Also check for directive/implementation language\n    const hasImplementationWords = /\\b(to achieve|implement|steps|following|procedure|process):/i.test(desc);\n    const hasSteps = hasListMarkers || hasImplementationWords;\n    const points = hasSteps ? 0 : 25;\n    const violations = hasSteps ? [\n        \"Description contains implementation steps. Move steps to Guidance section. Description should only state the outcome/requirement.\"\n    ] : undefined;\n    return {\n        id: \"desc.no_steps\",\n        label: \"No implementation steps\",\n        points,\n        max: 25,\n        status: points === 25 ? \"PASS\" : \"FAIL\",\n        notes: violations?.[0],\n        violations\n    };\n}\n// FIX #1: Change min_words to 20 instead of 25\n// UPDATED: Description word count 20-50 (not 20-120)\n// FIX 1: Change word count to 15-45\nfunction evalDescWordCount(desc) {\n    const words = desc.trim().split(/\\s+/).length;\n    const min = 15; // Changed from 20\n    const max = 45; // Changed from 50\n    const withinBounds = words >= min && words <= max;\n    let points = 20;\n    const violations = [];\n    if (words < min) {\n        points -= 10;\n        violations.push(`Too brief (${words} words). Add clarity. Aim for ${min}-${max} words.`);\n    } else if (words > max) {\n        points -= 8;\n        violations.push(`Too verbose (${words} words). Be concise. Aim for ${min}-${max} words.`);\n    }\n    return {\n        id: \"desc.word_count\",\n        label: `Word count (${min}-${max})`,\n        points: withinBounds ? points : Math.max(0, points),\n        max: 20,\n        status: withinBounds ? \"PASS\" : points >= 12 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? violations : undefined\n    };\n}\n// FIX #2: Improved acronym detection - checks both before AND after\nfunction evalDescStandaloneClarity(desc) {\n    const hasVagueTerms = /\\b(appropriate|adequate|reasonable|sufficient|proper|effective)\\b/i.test(desc);\n    // Find acronyms that are NOT expanded anywhere nearby (before or after)\n    const acronymPattern = /\\b([A-Z]{2,})\\b/g;\n    const acronyms = desc.match(acronymPattern) || [];\n    const unexpandedAcronyms = [];\n    for (const acronym of acronyms){\n        // Check if acronym is expanded in parentheses after it: \"DPO (Data Protection Officer)\"\n        const expandedAfter = new RegExp(`\\\\b${acronym}\\\\b\\\\s*\\\\([^)]+\\\\)`).test(desc);\n        // Check if acronym is in parentheses after expansion: \"Data Protection Officer (DPO)\"\n        const expandedBefore = new RegExp(`\\\\([^)]*\\\\b${acronym}\\\\b[^)]*\\\\)`).test(desc);\n        if (!expandedAfter && !expandedBefore) {\n            unexpandedAcronyms.push(acronym);\n        }\n    }\n    let points = 20;\n    const violations = [];\n    if (hasVagueTerms) {\n        points -= 8;\n        violations.push(\"Avoid vague qualifiers (appropriate/adequate). Be specific about requirements.\");\n    }\n    if (unexpandedAcronyms.length > 0) {\n        const acronym = unexpandedAcronyms[0];\n        points -= 5;\n        violations.push(`Expand acronym on first use: \"${acronym}\" → \"Full Term (${acronym})\"`);\n    }\n    return {\n        id: \"desc.standalone_clarity\",\n        label: \"Standalone clarity\",\n        points: Math.max(0, points),\n        max: 20,\n        status: points === 20 ? \"PASS\" : points >= 12 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\n// ========== GUIDANCE QUALITY CHECKS (40% weight) ==========\n// FIX #3: Check if guidance STARTS with a list marker (not just contains it)\n// UPDATED: Much stricter preamble detection - 0 points if no real preamble\n// UPDATED evalGuidancePreamble - More flexible objective/rationale detection\n// UPDATED evalGuidancePreamble - More flexible objective/rationale detection\n// UPDATED evalGuidancePreamble - More flexible objective/rationale detection\nfunction evalGuidancePreamble(guidance) {\n    const lines = guidance.split(\"\\n\").filter((l)=>l.trim());\n    if (lines.length === 0) {\n        return {\n            id: \"guid.preamble\",\n            label: \"Preamble (what + why)\",\n            points: 0,\n            max: 30,\n            status: \"FAIL\",\n            notes: \"Guidance is empty\",\n            violations: [\n                \"Add guidance with a preamble explaining objective and rationale\"\n            ]\n        };\n    }\n    // Check if FIRST line starts with a list marker or directive verb\n    const firstLine = lines[0].trim();\n    const startsWithList = /^(?:[-*•]|\\d+[.)]|[a-z][.)])\\s+/.test(firstLine);\n    const startsWithDirective = /^(deploy|implement|configure|monitor|review|establish|create|maintain|enable)\\b/i.test(firstLine);\n    // Extract preamble (text before first list marker)\n    const preambleMatch = guidance.match(/^([\\s\\S]+?)(?=\\n\\s*(?:[-*•]|\\d+[.)]|[a-z][.)])\\s+)/);\n    const preamble = preambleMatch ? preambleMatch[1].trim() : guidance.substring(0, 400);\n    // ✅ FIXED: More flexible objective detection\n    // NOW ACCEPTS:\n    // - \"to establish\" (original)\n    // - \"should establish\", \"must define\" (modal + verb)\n    // - \"aims to\", \"designed to\", etc.\n    const hasObjective = /\\b(objective|purpose|goal|aims?\\s+to|intended\\s+to|designed\\s+to|to\\s+(?:ensure|establish|support|define|create|maintain|implement)|(?:should|must|will)\\s+(?:establish|define|create|ensure|support|maintain|implement))\\b/i.test(preamble);\n    // ✅ FIXED: More flexible rationale detection\n    // NOW ACCEPTS:\n    // - \"to promote\" (original)\n    // - \"promotes\", \"enables\", \"supports\" (standalone verbs)\n    // - \"important\", \"critical\", \"because\" (existing)\n    const hasRationale = /\\b(rationale|because|important|critical|necessary|essential|to\\s+(?:support|enable|help|allow|protect|prevent|ensure|maintain|promote)|(?:promotes?|enables?|supports?|ensures?|maintains?|helps?|allows?|prevents?|protects?)\\b)/i.test(preamble);\n    // Preamble should be substantial (at least 15 words)\n    const preambleWords = preamble.split(/\\s+/).length;\n    const hasSubstantialPreamble = preambleWords >= 15;\n    let points = 30;\n    const violations = [];\n    // If guidance starts with a list or directive, there's no preamble - score 0\n    if (startsWithList || startsWithDirective) {\n        points = 0;\n        violations.push(\"No preamble found. Begin with 2-3 sentences explaining what this control achieves and why it matters before listing steps.\");\n        return {\n            id: \"guid.preamble\",\n            label: \"Preamble (what + why)\",\n            points: 0,\n            max: 30,\n            status: \"FAIL\",\n            notes: violations[0],\n            violations\n        };\n    }\n    // Otherwise, evaluate preamble quality\n    if (!hasSubstantialPreamble) {\n        points -= 12;\n        violations.push(`Preamble too brief (${preambleWords} words). Provide at least 2-3 sentences (15+ words) explaining the control's purpose.`);\n    }\n    if (!hasObjective) {\n        points -= 10;\n        violations.push(\"Preamble must state the objective (what this control achieves)\");\n    }\n    if (!hasRationale) {\n        points -= 8;\n        violations.push(\"Preamble must explain rationale (why this control matters)\");\n    }\n    return {\n        id: \"guid.preamble\",\n        label: \"Preamble (what + why)\",\n        points: Math.max(0, points),\n        max: 30,\n        status: points === 30 ? \"PASS\" : points >= 20 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalGuidanceStructuredSteps(guidance) {\n    const hasStructure = looksStructured(guidance);\n    const steps = extractSteps(guidance);\n    const stepCount = steps.length;\n    const min = spec.rules.guidance.steps_min || 2;\n    const max = spec.rules.guidance.steps_max || 8;\n    let points = 30;\n    const violations = [];\n    if (!hasStructure) {\n        points -= 15;\n        violations.push(\"Format steps as a numbered or bulleted list (e.g., 1. Step one; 2. Step two)\");\n    }\n    if (stepCount < min) {\n        points -= 10;\n        violations.push(`Too few steps (${stepCount}). Provide ${min}-${max} actionable steps.`);\n    } else if (stepCount > max) {\n        points -= 8;\n        violations.push(`Too many steps (${stepCount}). Consolidate to ${min}-${max} key steps.`);\n    }\n    return {\n        id: \"guid.structured_steps\",\n        label: `Structured steps (${min}-${max})`,\n        points: Math.max(0, points),\n        max: 30,\n        status: points === 30 ? \"PASS\" : points >= 18 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\n// FIX #4: Better action verb detection after list markers\nfunction evalGuidanceActionable(guidance) {\n    const steps = extractSteps(guidance);\n    // If we have structured steps, check if they start with action verbs\n    if (steps.length >= 2) {\n        const actionableSteps = steps.filter((step)=>{\n            // Remove list markers\n            const stepText = step.replace(/^\\s*(?:[-*•]|\\d+[.)]|[a-z][.)])\\s*/, \"\").trim();\n            const firstWord = stepText.split(/\\s+/)[0];\n            // Heuristic: Actionable if first word is:\n            // 1. Capitalized (imperative form)\n            // 2. Not a modal/article\n            // 3. At least 3 characters long\n            const isCapitalized = /^[A-Z]/.test(firstWord);\n            const notModalOrArticle = !/^(the|a|an|should|must|will|shall|may|can|could|would)$/i.test(firstWord);\n            const longEnough = firstWord.length >= 3;\n            return isCapitalized && notModalOrArticle && longEnough;\n        });\n        const ratio = actionableSteps.length / steps.length;\n        let points = Math.round(20 * ratio);\n        const violations = ratio < 1.0 ? [\n            `${steps.length - actionableSteps.length} step(s) don't start with action verbs. Begin with: implement, configure, review, monitor, etc.`\n        ] : undefined;\n        return {\n            id: \"guid.actionable\",\n            label: \"Steps are actionable\",\n            points,\n            max: 20,\n            status: points === 20 ? \"PASS\" : points >= 14 ? \"WARN\" : \"FAIL\",\n            notes: violations?.[0],\n            violations\n        };\n    }\n    // Fallback: If less than 2 steps, check for action verbs in general text\n    const actionVerbs = /\\b(implement|configure|review|monitor|document|define|establish|maintain|enable|create|develop|conduct|perform|verify|validate|assess|identify|ensure|designate|appoint|deploy|install|update|track|report|communicate|publish|record|escalate|investigate|remediate|disable)\\b/gi;\n    const matches = guidance.match(actionVerbs);\n    const actionVerbCount = matches ? matches.length : 0;\n    let points = 20;\n    const violations = [];\n    if (actionVerbCount === 0) {\n        points = 0;\n        violations.push(\"No action verbs found. Use actionable language (implement, configure, review, monitor, etc.)\");\n    } else if (actionVerbCount < 2) {\n        points = 10;\n        violations.push(\"Too few actionable instructions. Provide at least 2-3 action-oriented steps.\");\n    }\n    return {\n        id: \"guid.actionable\",\n        label: \"Steps are actionable\",\n        points,\n        max: 20,\n        status: points === 20 ? \"PASS\" : points >= 14 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? violations : undefined\n    };\n}\n// UPDATED: Evaluate tense/voice on actual content, not dependent on steps\nfunction evalGuidancePresentActive(guidance) {\n    // Look for present tense action verbs (imperatives) in the guidance\n    const presentImperatives = /\\b(implement|configure|review|monitor|document|define|establish|maintain|enable|create|develop|conduct|perform|verify|validate|assess|identify|designate|appoint)\\b/i.test(guidance);\n    // Check for past tense (wrong)\n    const hasPastTense = /\\b(configured|reviewed|implemented|established|created|developed|maintained|enabled|conducted|performed)\\b/i.test(guidance);\n    // Check for passive voice in guidance (wrong - should be active imperatives)\n    const hasPassive = /\\b(is|are|be)\\s+(?:configured|reviewed|implemented|established|maintained|enabled|conducted|performed)\\b/i.test(guidance);\n    let points = 20;\n    const violations = [];\n    if (!presentImperatives) {\n        points -= 10;\n        violations.push(\"Use present tense action verbs (e.g., 'Configure...', 'Review...', 'Monitor...')\");\n    }\n    if (hasPastTense) {\n        points -= 8;\n        violations.push(\"Avoid past tense (e.g., 'configured'). Use present tense imperatives (e.g., 'Configure')\");\n    }\n    if (hasPassive) {\n        points -= 7;\n        violations.push(\"Use active voice for steps (e.g., 'Review access logs' not 'Access logs are reviewed')\");\n    }\n    return {\n        id: \"guid.present_active\",\n        label: \"Present tense + active voice\",\n        points: Math.max(0, points),\n        max: 20,\n        status: points === 20 ? \"PASS\" : points >= 12 ? \"WARN\" : \"FAIL\",\n        notes: violations[0],\n        violations: violations.length > 0 ? dedupe(violations) : undefined\n    };\n}\nfunction evalGuidanceTechAgnostic(guidance) {\n    const vendorMatches = guidance.match(/\\b(aws|azure|gcp|google\\s+cloud|okta|servicenow|cisco|palo\\s*alto|fortinet|splunk|datadog|salesforce|snowflake|crowdstrike|microsoft|oracle|ibm|sap)\\b/gi) || [];\n    const hasVendor = vendorMatches.length > 0;\n    const points = hasVendor ? 10 : 20;\n    const uniqueVendors = Array.from(new Set(vendorMatches.map((v)=>v.toLowerCase())));\n    const vendorList = uniqueVendors.join(\", \");\n    const violations = hasVendor ? [\n        `Remove vendor/tool names (found ${vendorMatches.length}: \"${vendorList}\"). Use generic terms (e.g., \"identity management system\" not \"Okta\")`\n    ] : undefined;\n    return {\n        id: \"guid.tech_agnostic\",\n        label: \"Technology-agnostic\",\n        points,\n        max: 20,\n        status: points === 20 ? \"PASS\" : \"WARN\",\n        notes: violations?.[0],\n        violations\n    };\n}\nfunction evalGuidanceRoleNeutral(guidance) {\n    const hasRoleRef = ROLE_SPECIFIC.test(guidance);\n    const points = hasRoleRef ? 10 : 20;\n    const violations = hasRoleRef ? [\n        \"Avoid role-specific references (e.g., 'security team'). Keep guidance applicable across organizational structures.\"\n    ] : undefined;\n    return {\n        id: \"guid.role_neutral\",\n        label: \"Role-neutral\",\n        points,\n        max: 20,\n        status: points === 20 ? \"PASS\" : \"WARN\",\n        notes: violations?.[0],\n        violations\n    };\n}\nfunction evalGuidanceNoJargon(guidance) {\n    const hasJargon = JARGON_WORDS.test(guidance);\n    const points = hasJargon ? 12 : 20;\n    const jargon = guidance.match(JARGON_WORDS)?.[0];\n    const violations = hasJargon ? [\n        `Replace jargon \"${jargon}\" with plain language`\n    ] : undefined;\n    return {\n        id: \"guid.no_jargon\",\n        label: \"Plain language (no jargon)\",\n        points,\n        max: 20,\n        status: points === 20 ? \"PASS\" : \"WARN\",\n        notes: violations?.[0],\n        violations\n    };\n}\n// ========== AGGREGATION ==========\nfunction aggregateDimension(key, label, weight, checks) {\n    const totalMax = checks.reduce((sum, c)=>sum + c.max, 0);\n    const totalPoints = checks.reduce((sum, c)=>sum + c.points, 0);\n    const score = totalMax > 0 ? Math.round(totalPoints / totalMax * 100) : 0;\n    return {\n        key,\n        label,\n        score: Math.max(0, Math.min(100, score)),\n        max: 100,\n        weight,\n        checks\n    };\n}\nfunction buildMessages(...dims) {\n    const msgs = [];\n    for (const dim of dims){\n        for (const check of dim.checks){\n            if (check.status === \"FAIL\" && check.notes) {\n                msgs.push({\n                    level: \"FAIL\",\n                    text: check.notes\n                });\n            } else if (check.status === \"WARN\" && check.notes) {\n                msgs.push({\n                    level: \"WARN\",\n                    text: check.notes\n                });\n            }\n        }\n    }\n    return msgs.slice(0, 10);\n}\nfunction buildSuggestions(...dims) {\n    const suggestions = [];\n    const add = (s)=>{\n        if (s && !suggestions.includes(s)) suggestions.push(s);\n    };\n    // Collect unique suggestions from violations\n    for (const dim of dims){\n        for (const check of dim.checks){\n            if (check.violations) {\n                check.violations.forEach((v)=>add(v));\n            }\n        }\n    }\n    return suggestions.slice(0, 8);\n}\n// ========== MAIN SCORER ==========\nfunction scoreControl(item) {\n    const id = (item.id || \"\").trim();\n    const name = (item.name || \"\").trim();\n    const desc = (item.description || \"\").trim();\n    const guid = (item.guidance || \"\").trim();\n    // ID Dimension (15% weight)\n    const idChecks = [\n        evalIdStructured(id),\n        evalIdLength(id),\n        evalIdUniqueness(id)\n    ];\n    const idDim = aggregateDimension(\"id_quality\", \"Control ID Quality\", 0.15, idChecks);\n    // Name Dimension (15% weight)\n    const nameChecks = [\n        evalNameConcise(name),\n        evalNameActionOriented(name),\n        evalNamePurposeClarity(name),\n        evalNameRoleNeutral(name)\n    ];\n    const nameDim = aggregateDimension(\"name_quality\", \"Control Name Quality\", 0.15, nameChecks);\n    // Description Dimension (30% weight)\n    const descChecks = [\n        evalDescPresentTense(desc),\n        evalDescPassiveVoice(desc),\n        evalDescNoModalVerbs(desc),\n        evalDescSingleObjective(desc),\n        evalDescNoSteps(desc),\n        evalDescWordCount(desc),\n        evalDescStandaloneClarity(desc)\n    ];\n    const descDim = aggregateDimension(\"description_quality\", \"Description Quality\", 0.30, descChecks);\n    // Guidance Dimension (40% weight)\n    const guidChecks = [\n        evalGuidancePreamble(guid),\n        evalGuidanceStructuredSteps(guid),\n        evalGuidanceActionable(guid),\n        evalGuidancePresentActive(guid),\n        evalGuidanceTechAgnostic(guid),\n        evalGuidanceRoleNeutral(guid),\n        evalGuidanceNoJargon(guid)\n    ];\n    const guidDim = aggregateDimension(\"guidance_quality\", \"Guidance Quality\", 0.40, guidChecks);\n    // Calculate total score\n    const total = Math.round(idDim.score * 0.15 + nameDim.score * 0.15 + descDim.score * 0.30 + guidDim.score * 0.40);\n    // Check for critical failures (any check with max >= 15 that has status FAIL)\n    const criticalFail = [\n        idDim,\n        nameDim,\n        descDim,\n        guidDim\n    ].some((dim)=>dim.checks.some((check)=>check.status === \"FAIL\" && check.max >= 15));\n    // Determine verdict\n    let verdict;\n    if (criticalFail) {\n        verdict = \"fail\";\n    } else if (total >= (spec.scoring.thresholds.pass || 80)) {\n        verdict = \"pass\";\n    } else if (total >= (spec.scoring.thresholds.partial || 60)) {\n        verdict = \"partial\";\n    } else {\n        verdict = \"fail\";\n    }\n    return {\n        version: spec.meta.version || \"v1\",\n        verdict,\n        total: {\n            score: total,\n            max: 100,\n            formula: \"TOTAL = 0.15*ID + 0.15*NAME + 0.30*DESC + 0.40*GUIDANCE\",\n            weights: {\n                id: 0.15,\n                name: 0.15,\n                description: 0.30,\n                guidance: 0.40\n            },\n            gated_fail: criticalFail\n        },\n        dimensions: {\n            id_quality: idDim,\n            name_quality: nameDim,\n            description_quality: descDim,\n            guidance_quality: guidDim\n        },\n        messages: buildMessages(idDim, nameDim, descDim, guidDim),\n        suggestions: buildSuggestions(idDim, nameDim, descDim, guidDim)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1BySSxLQUFLO1lBQ0wrSSxTQUFTO1lBQ1RDLFNBQVM7Z0JBQ1B2SixJQUFJO2dCQUNKa0IsTUFBTTtnQkFDTmdILGFBQWE7Z0JBQ2JyRSxVQUFVO1lBQ1o7WUFDQTJGLFlBQVlYO1FBQ2Q7UUFDQVksWUFBWTtZQUNWQyxZQUFZckI7WUFDWnNCLGNBQWNwQjtZQUNkcUIscUJBQXFCbkI7WUFDckJvQixrQkFBa0JsQjtRQUNwQjtRQUNBbUIsVUFBVXpDLGNBQWNnQixPQUFPRSxTQUFTRSxTQUFTRTtRQUNqRGQsYUFBYUQsaUJBQWlCUyxPQUFPRSxTQUFTRSxTQUFTRTtJQUN6RDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVhZGxpbmVzLWRlbW8tdWkvLi9zY29yZXIvY29udHJvbHMudHM/NTg5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY29yZXIvY29udHJvbHMudHMgLSBFbmhhbmNlZCBDb250cm9sIFNjb3JpbmcgYWxpZ25lZCB3aXRoIEdSQyBDb250ZW50IFN0YW5kYXJkXG5cbmltcG9ydCBjb250cm9sc1NwZWNKc29uIGZyb20gXCIuLi9zcGVjcy9jb250cm9sc19zdGFuZGFyZC52MS5qc29uXCIgYXNzZXJ0IHsgdHlwZTogXCJqc29uXCIgfTtcbmNvbnN0IHNwZWMgPSBjb250cm9sc1NwZWNKc29uIGFzIGFueTtcblxuLy8gPT09PT09PT09PSBUWVBFUyA9PT09PT09PT09XG5leHBvcnQgdHlwZSBDaGVja1N0YXR1cyA9IFwiUEFTU1wiIHwgXCJXQVJOXCIgfCBcIkZBSUxcIiB8IFwiTi9BXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgaWQ6IHN0cmluZztcbiAgbGFiZWw6IHN0cmluZztcbiAgcG9pbnRzOiBudW1iZXI7XG4gIG1heDogbnVtYmVyO1xuICBzdGF0dXM6IENoZWNrU3RhdHVzO1xuICBub3Rlcz86IHN0cmluZztcbiAgdmlvbGF0aW9ucz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpbWVuc2lvblJlc3VsdCB7XG4gIGtleTogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICBzY29yZTogbnVtYmVyO1xuICBtYXg6IG51bWJlcjtcbiAgd2VpZ2h0OiBudW1iZXI7XG4gIGNoZWNrczogU2NvcmluZ0NoZWNrUmVzdWx0W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udHJvbFNjb3JlUmVzcG9uc2Uge1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIHZlcmRpY3Q6IFwicGFzc1wiIHwgXCJwYXJ0aWFsXCIgfCBcImZhaWxcIjtcbiAgdG90YWw6IHtcbiAgICBzY29yZTogbnVtYmVyO1xuICAgIG1heDogbnVtYmVyO1xuICAgIGZvcm11bGE6IHN0cmluZztcbiAgICB3ZWlnaHRzOiB7IGlkOiBudW1iZXI7IG5hbWU6IG51bWJlcjsgZGVzY3JpcHRpb246IG51bWJlcjsgZ3VpZGFuY2U6IG51bWJlciB9O1xuICAgIGdhdGVkX2ZhaWw/OiBib29sZWFuO1xuICB9O1xuICBkaW1lbnNpb25zOiB7XG4gICAgaWRfcXVhbGl0eTogRGltZW5zaW9uUmVzdWx0O1xuICAgIG5hbWVfcXVhbGl0eTogRGltZW5zaW9uUmVzdWx0O1xuICAgIGRlc2NyaXB0aW9uX3F1YWxpdHk6IERpbWVuc2lvblJlc3VsdDtcbiAgICBndWlkYW5jZV9xdWFsaXR5OiBEaW1lbnNpb25SZXN1bHQ7XG4gIH07XG4gIG1lc3NhZ2VzOiB7IGxldmVsOiBcIlBBU1NcIiB8IFwiV0FSTlwiIHwgXCJGQUlMXCI7IHRleHQ6IHN0cmluZyB9W107XG4gIHN1Z2dlc3Rpb25zOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IHR5cGUgQ29udHJvbElucHV0ID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGd1aWRhbmNlOiBzdHJpbmc7XG4gIGZyYW1ld29yaz86IHN0cmluZztcbn07XG5cbi8vID09PT09PT09PT0gVVRJTElUSUVTID09PT09PT09PT1cbmZ1bmN0aW9uIGRlZHVwZShhcnI/OiBzdHJpbmdbXSkge1xuICBpZiAoIWFycikgcmV0dXJuIGFycjtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnIuZmlsdGVyKEJvb2xlYW4pKSk7XG59XG5cbmZ1bmN0aW9uIGxvb2tzU3RydWN0dXJlZCh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC8oXnxcXG4pXFxzKig/OlstKuKAol18XFxkK1suKV18W2Etel1bLildKVxccysvbS50ZXN0KHRleHQpO1xufVxuXG5mdW5jdGlvbiBjb3VudFNlbnRlbmNlcyh0ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gdGV4dC5zcGxpdCgvWy4hP10rLykuZmlsdGVyKHMgPT4gcy50cmltKCkubGVuZ3RoID4gMCkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U3RlcHModGV4dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBzdGVwczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIC8vIE1ldGhvZCAxOiBFeHRyYWN0IHN0ZXBzIG9uIHNlcGFyYXRlIGxpbmVzXG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGlmICgvXlxccyooPzpbLSrigKJdfFxcZCtbLildfFthLXpdWy4pXSlcXHMrKC4rKS8udGVzdChsaW5lKSkge1xuICAgICAgc3RlcHMucHVzaChsaW5lLnRyaW0oKSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBNZXRob2QgMjogSWYgbm8gbGluZS1iYXNlZCBzdGVwcywgbG9vayBmb3IgaW5saW5lIG51bWJlcmVkIHN0ZXBzXG4gIGlmIChzdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBGaW5kIEFMTCBcIm51bWJlci4gdGV4dFwiIHBhdHRlcm5zIHVzaW5nIGdsb2JhbCByZWdleFxuICAgIGNvbnN0IHBhdHRlcm4gPSAvKFxcZCtbLildKVxccyooW147XSspL2c7XG4gICAgbGV0IG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzdGVwVGV4dCA9IG1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChzdGVwVGV4dC5sZW5ndGggPiA1KSB7XG4gICAgICAgIHN0ZXBzLnB1c2goc3RlcFRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHN0ZXBzO1xufVxuXG4vLyA9PT09PT09PT09IFJFR0VYIFBBVFRFUk5TID09PT09PT09PT1cbmNvbnN0IE1PREFMX1ZFUkJTID0gL1xcYihzaG91bGR8Y291bGR8bWF5fG1pZ2h0fG11c3R8c2hhbGx8ZW5zdXJlfGVuc3VyZXN8ZW5zdXJlZClcXGIvaTtcbmNvbnN0IFZFTkRPUl9OQU1FUyA9IC9cXGIoYXdzfGF6dXJlfGdjcHxnb29nbGVcXHMrY2xvdWR8b2t0YXxzZXJ2aWNlbm93fGNpc2NvfHBhbG9cXHMqYWx0b3xmb3J0aW5ldHxzcGx1bmt8ZGF0YWRvZ3xzYWxlc2ZvcmNlfHNub3dmbGFrZXxjcm93ZHN0cmlrZXxtaWNyb3NvZnR8b3JhY2xlfGlibXxzYXApXFxiL2k7XG5jb25zdCBKQVJHT05fV09SRFMgPSAvXFxiKHV0aWxpemV8bGV2ZXJhZ2V8c3luZXJneXxob2xpc3RpY3xiZXN0Wy1cXHNdP29mWy1cXHNdP2JyZWVkfG9wZXJhdGlvbmFsaXplKVxcYi9pO1xuY29uc3QgUk9MRV9TUEVDSUZJQyA9IC9cXGIoaXR8c2VjdXJpdHl8ZW5naW5lZXJpbmd8ZGV2b3BzfGF1ZGl0fHByaXZhY3l8aHJ8bGVnYWx8ZmluYW5jZSlcXHMrKHRlYW18ZGVwdHxkZXBhcnRtZW50fGFkbWluaXN0cmF0b3J8bWFuYWdlcilcXGIvaTtcbmNvbnN0IERJUkVDVElWRV9WRVJCUyA9IC9eXFxzKihjb25maWd1cmV8aW5zdGFsbHxkZXBsb3l8ZW5hYmxlfHNldFxccyp1cHxjcmVhdGV8ZGV2ZWxvcHxpbXBsZW1lbnR8ZXN0YWJsaXNofGRlZmluZSlcXGIvaTtcbmNvbnN0IFBSRVNFTlRfVEVOU0VfSU5ESUNBVE9SUyA9IC9cXGIoaXN8YXJlfGhhc3xoYXZlfGV4aXN0cz98cmVtYWlucz98aW5jbHVkZXM/fGNvbnRhaW5zP3xwcm92aWRlcz98ZW5zdXJlcz98bWFpbnRhaW5zP3xzdXBwb3J0cz98cGVyZm9ybXM/fGNvbmR1Y3RzPylcXGIvaTtcbmNvbnN0IFBBU1NJVkVfVk9JQ0VfSU5ESUNBVE9SUyA9IC9cXGIoaXN8YXJlfGJlfGJlaW5nfGJlZW4pXFxzK1thLXpdK2VkXFxiL2k7XG5jb25zdCBBQ1RJT05fV09SRFMgPSAvXFxiKHByb3RlY3Rpb258ZGV0ZWN0aW9ufG1vbml0b3Jpbmd8cmV2aWV3fGFzc2Vzc21lbnR8bWFuYWdlbWVudHxpbXBsZW1lbnRhdGlvbnxjb25maWd1cmF0aW9ufGVzdGFibGlzaG1lbnR8bWFpbnRlbmFuY2V8cGxhbm5pbmd8dGVzdGluZ3xhdWRpdGluZ3x0cmFja2luZ3xyZXBvcnRpbmd8dHJhaW5pbmd8ZW5mb3JjZW1lbnR8dmFsaWRhdGlvbnx2ZXJpZmljYXRpb258YW5hbHlzaXMpXFxiL2k7XG5cbi8vID09PT09PT09PT0gSUQgUVVBTElUWSBDSEVDS1MgKDE1JSB3ZWlnaHQpID09PT09PT09PT1cblxuZnVuY3Rpb24gZXZhbElkU3RydWN0dXJlZChpZDogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3QgaGFzU2VwYXJhdG9yID0gaWQuaW5jbHVkZXMoXCIuXCIpO1xuICBjb25zdCBwb2ludHMgPSBoYXNTZXBhcmF0b3IgPyAyMCA6IDEyO1xuICBjb25zdCB2aW9sYXRpb25zID0gaGFzU2VwYXJhdG9yID8gdW5kZWZpbmVkIDogW1wiVXNlIHN0cnVjdHVyZWQgZm9ybWF0IHdpdGggc2VwYXJhdG9yIChlLmcuLCBHRFBSLjEuMSBvciBOSVNULkFDLjEpXCJdO1xuICByZXR1cm4ge1xuICAgIGlkOiBcImlkLnN0cnVjdHVyZWRcIixcbiAgICBsYWJlbDogXCJTdHJ1Y3R1cmVkIGZvcm1hdCAocHJlZml4LnNlY3Rpb24ubnVtYmVyKVwiLFxuICAgIHBvaW50cyxcbiAgICBtYXg6IDIwLFxuICAgIHN0YXR1czogcG9pbnRzID09PSAyMCA/IFwiUEFTU1wiIDogXCJXQVJOXCIsXG4gICAgbm90ZXM6IHZpb2xhdGlvbnM/LlswXSxcbiAgICB2aW9sYXRpb25zXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2YWxJZExlbmd0aChpZDogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3QgbGVuID0gaWQubGVuZ3RoO1xuICBjb25zdCB3aXRoaW5Cb3VuZHMgPSBsZW4gPiAwICYmIGxlbiA8PSAoc3BlYy5ydWxlcy5pZC5tYXhfbGVuZ3RoIHx8IDI0KTtcbiAgY29uc3QgcG9pbnRzID0gd2l0aGluQm91bmRzID8gMTUgOiBsZW4gPiAyNCA/IDggOiAwO1xuICBjb25zdCB2aW9sYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBpZiAoIXdpdGhpbkJvdW5kcykge1xuICAgIGlmIChsZW4gPT09IDApIHZpb2xhdGlvbnMucHVzaChcIklEIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICBlbHNlIHZpb2xhdGlvbnMucHVzaChgSUQgdG9vIGxvbmcgKCR7bGVufSBjaGFycykuIEtlZXAgdW5kZXIgJHtzcGVjLnJ1bGVzLmlkLm1heF9sZW5ndGggfHwgMjR9IGNoYXJhY3RlcnMuYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogXCJpZC5sZW5ndGhcIixcbiAgICBsYWJlbDogXCJBcHByb3ByaWF0ZSBsZW5ndGhcIixcbiAgICBwb2ludHMsXG4gICAgbWF4OiAxNSxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMTUgPyBcIlBBU1NcIiA6IHBvaW50cyA+PSAxMCA/IFwiV0FSTlwiIDogXCJGQUlMXCIsXG4gICAgbm90ZXM6IHZpb2xhdGlvbnNbMF0sXG4gICAgdmlvbGF0aW9uczogdmlvbGF0aW9ucy5sZW5ndGggPiAwID8gdmlvbGF0aW9ucyA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5mdW5jdGlvbiBldmFsSWRVbmlxdWVuZXNzKGlkOiBzdHJpbmcpOiBTY29yaW5nQ2hlY2tSZXN1bHQge1xuICAvLyBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgLSBpbiByZWFsIGltcGxlbWVudGF0aW9uIHdvdWxkIGNoZWNrIGFnYWluc3QgZGF0YWJhc2VcbiAgLy8gRm9yIE1WUCwgd2UganVzdCB2YWxpZGF0ZSBpdCdzIG5vdCBvYnZpb3VzbHkgaW52YWxpZFxuICBjb25zdCBoYXNDb250ZW50ID0gaWQudHJpbSgpLmxlbmd0aCA+IDA7XG4gIHJldHVybiB7XG4gICAgaWQ6IFwiaWQudW5pcXVlbmVzc1wiLFxuICAgIGxhYmVsOiBcIlVuaXF1ZW5lc3MgKGFzc3VtZWQgd2l0aGluIGZyYW1ld29yaylcIixcbiAgICBwb2ludHM6IGhhc0NvbnRlbnQgPyAxNSA6IDAsXG4gICAgbWF4OiAxNSxcbiAgICBzdGF0dXM6IGhhc0NvbnRlbnQgPyBcIlBBU1NcIiA6IFwiRkFJTFwiLFxuICAgIG5vdGVzOiBoYXNDb250ZW50ID8gXCJVbmlxdWVuZXNzIHZhbGlkYXRpb24gcmVxdWlyZXMgZGF0YWJhc2UgY2hlY2tcIiA6IFwiSUQgaXMgZW1wdHlcIlxuICB9O1xufVxuXG4vLyA9PT09PT09PT09IE5BTUUgUVVBTElUWSBDSEVDS1MgKDE1JSB3ZWlnaHQpID09PT09PT09PT1cblxuZnVuY3Rpb24gZXZhbE5hbWVDb25jaXNlKG5hbWU6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IHdvcmRzID0gbmFtZS50cmltKCkuc3BsaXQoL1xccysvKS5sZW5ndGg7XG4gIGNvbnN0IG1heFdvcmRzID0gc3BlYy5ydWxlcy5uYW1lLmNvbmNpc2VfbWF4X3dvcmRzIHx8IDEyO1xuICBjb25zdCB3aXRoaW5Cb3VuZHMgPSB3b3JkcyA+IDAgJiYgd29yZHMgPD0gbWF4V29yZHM7XG4gIGNvbnN0IHBvaW50cyA9IHdpdGhpbkJvdW5kcyA/IDI1IDogd29yZHMgPiBtYXhXb3JkcyA/IDE1IDogMDtcbiAgY29uc3QgdmlvbGF0aW9ucyA9IHdpdGhpbkJvdW5kcyA/IHVuZGVmaW5lZCA6IHdvcmRzID09PSAwID8gW1wiTmFtZSBjYW5ub3QgYmUgZW1wdHlcIl0gOiBbYFRvbyB2ZXJib3NlICgke3dvcmRzfSB3b3JkcykuIEtlZXAgdW5kZXIgJHttYXhXb3Jkc30gd29yZHMuYF07XG4gIHJldHVybiB7XG4gICAgaWQ6IFwibmFtZS5jb25jaXNlXCIsXG4gICAgbGFiZWw6IFwiQ29uY2lzZSAo4omkMTIgd29yZHMpXCIsXG4gICAgcG9pbnRzLFxuICAgIG1heDogMjUsXG4gICAgc3RhdHVzOiBwb2ludHMgPT09IDI1ID8gXCJQQVNTXCIgOiBwb2ludHMgPj0gMTUgPyBcIldBUk5cIiA6IFwiRkFJTFwiLFxuICAgIG5vdGVzOiB2aW9sYXRpb25zPy5bMF0sXG4gICAgdmlvbGF0aW9uc1xuICB9O1xufVxuXG5mdW5jdGlvbiBldmFsTmFtZUFjdGlvbk9yaWVudGVkKG5hbWU6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IGhhc0FjdGlvbldvcmQgPSBBQ1RJT05fV09SRFMudGVzdChuYW1lKTtcbiAgY29uc3QgaXNWYWd1ZSA9IC9cXGIodGhpbmdzfHN0dWZmfGl0ZW1zfG1hdHRlcnN8aXNzdWVzKVxcYi9pLnRlc3QobmFtZSk7XG4gIGxldCBwb2ludHMgPSAyNTtcbiAgY29uc3QgdmlvbGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIGlmICghaGFzQWN0aW9uV29yZCkge1xuICAgIHBvaW50cyAtPSA4O1xuICAgIHZpb2xhdGlvbnMucHVzaChcIlVzZSBhY3Rpb24tb3JpZW50ZWQgb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgKGUuZy4sICdQcm90ZWN0aW9uIG9mLi4uJywgJ0FjY2VzcyBSZXZpZXcgUHJvY2VzcycpXCIpO1xuICB9XG4gIGlmIChpc1ZhZ3VlKSB7XG4gICAgcG9pbnRzIC09IDU7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiQXZvaWQgdmFndWUgdGVybXMuIEJlIHNwZWNpZmljIGFib3V0IHdoYXQgdGhlIGNvbnRyb2wgYWRkcmVzc2VzLlwiKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpZDogXCJuYW1lLmFjdGlvbl9vcmllbnRlZFwiLFxuICAgIGxhYmVsOiBcIkFjdGlvbi1vcmllbnRlZCBvciBzcGVjaWZpYyBsYW5ndWFnZVwiLFxuICAgIHBvaW50czogTWF0aC5tYXgoMCwgcG9pbnRzKSxcbiAgICBtYXg6IDI1LFxuICAgIHN0YXR1czogcG9pbnRzID09PSAyNSA/IFwiUEFTU1wiIDogcG9pbnRzID49IDE4ID8gXCJXQVJOXCIgOiBcIkZBSUxcIixcbiAgICBub3RlczogdmlvbGF0aW9uc1swXSxcbiAgICB2aW9sYXRpb25zOiB2aW9sYXRpb25zLmxlbmd0aCA+IDAgPyBkZWR1cGUodmlvbGF0aW9ucykgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZhbE5hbWVQdXJwb3NlQ2xhcml0eShuYW1lOiBzdHJpbmcpOiBTY29yaW5nQ2hlY2tSZXN1bHQge1xuICBjb25zdCB0b29TaG9ydCA9IG5hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykubGVuZ3RoIDwgMjtcbiAgY29uc3QgdG9vR2VuZXJpYyA9IC9eKHNlY3VyaXR5fGNvbXBsaWFuY2V8Y29udHJvbHM/fG1hbmFnZW1lbnR8c3lzdGVtKSQvaS50ZXN0KG5hbWUudHJpbSgpKTtcbiAgbGV0IHBvaW50cyA9IDI1O1xuICBjb25zdCB2aW9sYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgaWYgKHRvb1Nob3J0KSB7XG4gICAgcG9pbnRzIC09IDEwO1xuICAgIHZpb2xhdGlvbnMucHVzaChcIk5hbWUgdG9vIHNob3J0LiBBZGQgY29udGV4dCBhYm91dCB0aGUgY29udHJvbCdzIHB1cnBvc2UuXCIpO1xuICB9XG4gIGlmICh0b29HZW5lcmljKSB7XG4gICAgcG9pbnRzIC09IDEwO1xuICAgIHZpb2xhdGlvbnMucHVzaChcIk5hbWUgdG9vIGdlbmVyaWMuIFNwZWNpZnkgd2hhdCBhc3BlY3QgaXMgYmVpbmcgY29udHJvbGxlZC5cIik7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IFwibmFtZS5wdXJwb3NlX2NsYXJpdHlcIixcbiAgICBsYWJlbDogXCJQdXJwb3NlIGNsYXJpdHlcIixcbiAgICBwb2ludHM6IE1hdGgubWF4KDAsIHBvaW50cyksXG4gICAgbWF4OiAyNSxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMjUgPyBcIlBBU1NcIiA6IHBvaW50cyA+PSAxOCA/IFwiV0FSTlwiIDogXCJGQUlMXCIsXG4gICAgbm90ZXM6IHZpb2xhdGlvbnNbMF0sXG4gICAgdmlvbGF0aW9uczogdmlvbGF0aW9ucy5sZW5ndGggPiAwID8gZGVkdXBlKHZpb2xhdGlvbnMpIDogdW5kZWZpbmVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2YWxOYW1lUm9sZU5ldXRyYWwobmFtZTogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3QgaGFzUm9sZVJlZiA9IFJPTEVfU1BFQ0lGSUMudGVzdChuYW1lKTtcbiAgY29uc3QgcG9pbnRzID0gaGFzUm9sZVJlZiA/IDE1IDogMjU7XG4gIGNvbnN0IHZpb2xhdGlvbnMgPSBoYXNSb2xlUmVmID8gW1wiQXZvaWQgcm9sZS1zcGVjaWZpYyByZWZlcmVuY2VzIGluIHRoZSBuYW1lIHRvIGVuc3VyZSBhcHBsaWNhYmlsaXR5IGFjcm9zcyBvcmdhbml6YXRpb25hbCBzdHJ1Y3R1cmVzXCJdIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIGlkOiBcIm5hbWUucm9sZV9uZXV0cmFsXCIsXG4gICAgbGFiZWw6IFwiUm9sZS1uZXV0cmFsXCIsXG4gICAgcG9pbnRzLFxuICAgIG1heDogMjUsXG4gICAgc3RhdHVzOiBwb2ludHMgPT09IDI1ID8gXCJQQVNTXCIgOiBcIldBUk5cIixcbiAgICBub3RlczogdmlvbGF0aW9ucz8uWzBdLFxuICAgIHZpb2xhdGlvbnNcbiAgfTtcbn1cblxuLy8gPT09PT09PT09PSBERVNDUklQVElPTiBRVUFMSVRZIENIRUNLUyAoMzAlIHdlaWdodCkgPT09PT09PT09PVxuXG5mdW5jdGlvbiBldmFsRGVzY1ByZXNlbnRUZW5zZShkZXNjOiBzdHJpbmcpOiBTY29yaW5nQ2hlY2tSZXN1bHQge1xuICBjb25zdCBoYXNQcmVzZW50VGVuc2UgPSBQUkVTRU5UX1RFTlNFX0lORElDQVRPUlMudGVzdChkZXNjKTtcbiAgY29uc3QgaGFzRnV0dXJlVGVuc2UgPSAvXFxiKHdpbGx8c2hhbGx8Z29pbmcgdG8pXFxiL2kudGVzdChkZXNjKTtcbiAgbGV0IHBvaW50cyA9IDI1O1xuICBjb25zdCB2aW9sYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgaWYgKCFoYXNQcmVzZW50VGVuc2UpIHtcbiAgICBwb2ludHMgLT0gMTA7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiVXNlIHByZXNlbnQgdGVuc2UgdG8gY29udmV5IHRoZSByZXF1aXJlbWVudCBpcyBhbHdheXMgYXBwbGljYWJsZSAoZS5nLiwgJ2lzIGNvbmZpZ3VyZWQnLCAnYXJlIHJldmlld2VkJylcIik7XG4gIH1cbiAgaWYgKGhhc0Z1dHVyZVRlbnNlKSB7XG4gICAgcG9pbnRzIC09IDg7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiQXZvaWQgZnV0dXJlIHRlbnNlICgnd2lsbCBiZScpLiBVc2UgcHJlc2VudCB0ZW5zZSAoJ2lzJykuXCIpO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBcImRlc2MucHJlc2VudF90ZW5zZVwiLFxuICAgIGxhYmVsOiBcIlByZXNlbnQgdGVuc2VcIixcbiAgICBwb2ludHM6IE1hdGgubWF4KDAsIHBvaW50cyksXG4gICAgbWF4OiAyNSxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMjUgPyBcIlBBU1NcIiA6IHBvaW50cyA+PSAxNSA/IFwiV0FSTlwiIDogXCJGQUlMXCIsXG4gICAgbm90ZXM6IHZpb2xhdGlvbnNbMF0sXG4gICAgdmlvbGF0aW9uczogdmlvbGF0aW9ucy5sZW5ndGggPiAwID8gZGVkdXBlKHZpb2xhdGlvbnMpIDogdW5kZWZpbmVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2YWxEZXNjUGFzc2l2ZVZvaWNlKGRlc2M6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IGhhc1Bhc3NpdmUgPSBQQVNTSVZFX1ZPSUNFX0lORElDQVRPUlMudGVzdChkZXNjKTtcbiAgY29uc3QgaGFzQWN0aXZlRGlyZWN0aXZlID0gRElSRUNUSVZFX1ZFUkJTLnRlc3QoZGVzYykgfHwgUk9MRV9TUEVDSUZJQy50ZXN0KGRlc2MpO1xuICBsZXQgcG9pbnRzID0gMjU7XG4gIGNvbnN0IHZpb2xhdGlvbnM6IHN0cmluZ1tdID0gW107XG4gIFxuICBpZiAoIWhhc1Bhc3NpdmUpIHtcbiAgICBwb2ludHMgLT0gODtcbiAgICB2aW9sYXRpb25zLnB1c2goXCJQcmVmZXIgcGFzc2l2ZSB2b2ljZSBmb3Igcm9sZS1uZXV0cmFsaXR5IChlLmcuLCAnRGF0YSBpcyBlbmNyeXB0ZWQnIG5vdCAnSVQgZW5jcnlwdHMgZGF0YScpXCIpO1xuICB9XG4gIGlmIChoYXNBY3RpdmVEaXJlY3RpdmUpIHtcbiAgICBwb2ludHMgLT0gMTA7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiQXZvaWQgYWN0aXZlIHZvaWNlIGRpcmVjdGl2ZXMuIFN0YXRlIHRoZSBjb25kaXRpb24vb3V0Y29tZSwgbm90IHdobyBwZXJmb3JtcyBpdC5cIik7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IFwiZGVzYy5wYXNzaXZlX3ZvaWNlXCIsXG4gICAgbGFiZWw6IFwiUGFzc2l2ZSB2b2ljZSAocm9sZS1uZXV0cmFsKVwiLFxuICAgIHBvaW50czogTWF0aC5tYXgoMCwgcG9pbnRzKSxcbiAgICBtYXg6IDI1LFxuICAgIHN0YXR1czogcG9pbnRzID09PSAyNSA/IFwiUEFTU1wiIDogcG9pbnRzID49IDE1ID8gXCJXQVJOXCIgOiBcIkZBSUxcIixcbiAgICBub3RlczogdmlvbGF0aW9uc1swXSxcbiAgICB2aW9sYXRpb25zOiB2aW9sYXRpb25zLmxlbmd0aCA+IDAgPyBkZWR1cGUodmlvbGF0aW9ucykgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZhbERlc2NOb01vZGFsVmVyYnMoZGVzYzogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3QgaGFzTW9kYWwgPSBNT0RBTF9WRVJCUy50ZXN0KGRlc2MpO1xuICBjb25zdCBwb2ludHMgPSBoYXNNb2RhbCA/IDAgOiAyNTtcbiAgY29uc3QgdmlvbGF0aW9ucyA9IGhhc01vZGFsID8gW1wiUmVtb3ZlIG1vZGFsIHZlcmJzIChzaG91bGQvY291bGQvbWF5L211c3QvZW5zdXJlKS4gU3RhdGUgdGhlIHJlcXVpcmVtZW50IGRlZmluaXRpdmVseSBpbiBwcmVzZW50IHRlbnNlLlwiXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgICBpZDogXCJkZXNjLm5vX21vZGFsX3ZlcmJzXCIsXG4gICAgbGFiZWw6IFwiTm8gbW9kYWwgdmVyYnMgKHNob3VsZC9tdXN0L3NoYWxsL2Vuc3VyZSlcIixcbiAgICBwb2ludHMsXG4gICAgbWF4OiAyNSxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMjUgPyBcIlBBU1NcIiA6IFwiRkFJTFwiLFxuICAgIG5vdGVzOiB2aW9sYXRpb25zPy5bMF0sXG4gICAgdmlvbGF0aW9uc1xuICB9O1xufVxuXG4vLyBGSVggMjogQmV0dGVyIFwiU2luZ2xlIG9iamVjdGl2ZVwiIGNoZWNrIC0gZm9jdXMgb24gbXVsdGlwbGUgT1VUQ09NRVMsIG5vdCBzZW50ZW5jZXNcbmZ1bmN0aW9uIGV2YWxEZXNjU2luZ2xlT2JqZWN0aXZlKGRlc2M6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIC8vIENoZWNrIGZvciBtdWx0aXBsZSBkaXN0aW5jdCBvdXRjb21lcyAobm90IGp1c3Qgc2VudGVuY2UgY291bnQpXG4gIGNvbnN0IGhhc011bHRpcGxlQW5kcyA9IChkZXNjLm1hdGNoKC9cXGJhbmRcXGIvZ2kpIHx8IFtdKS5sZW5ndGggPj0gMztcbiAgY29uc3QgaGFzT3JDbGF1c2VzID0gL1xcYm9yXFxiL2dpLnRlc3QoZGVzYyk7XG4gIFxuICAvLyBDaGVjayBmb3IgbXVsdGlwbGUgb3V0Y29tZSBzdGF0ZW1lbnRzIChtdWx0aXBsZSBcImlzL2FyZVwiIHN0YXRlbWVudHMpXG4gIGNvbnN0IG91dGNvbWVTdGF0ZW1lbnRzID0gZGVzYy5tYXRjaCgvXFxiKGlzfGFyZSlcXHMrW2Etel0rZWRcXGIvZ2kpIHx8IFtdO1xuICBjb25zdCBtdWx0aXBsZU91dGNvbWVzID0gb3V0Y29tZVN0YXRlbWVudHMubGVuZ3RoID4gMjtcbiAgXG4gIGxldCBwb2ludHMgPSAyMDtcbiAgY29uc3QgdmlvbGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIGlmIChtdWx0aXBsZU91dGNvbWVzKSB7XG4gICAgcG9pbnRzIC09IDEwO1xuICAgIHZpb2xhdGlvbnMucHVzaChgTXVsdGlwbGUgb3V0Y29tZXMgZGV0ZWN0ZWQgKCR7b3V0Y29tZVN0YXRlbWVudHMubGVuZ3RofSBkaWZmZXJlbnQgc3RhdGVzL3Jlc3VsdHMpLiBGb2N1cyBvbiBvbmUgb3V0Y29tZSBwZXIgY29udHJvbC5gKTtcbiAgfVxuICBpZiAoaGFzTXVsdGlwbGVBbmRzKSB7XG4gICAgcG9pbnRzIC09IDU7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiVG9vIG1hbnkgJ2FuZCcgY29uanVuY3Rpb25zLiBDb25zaWRlciBpZiB0aGlzIGlzIGFjdHVhbGx5IG11bHRpcGxlIGNvbnRyb2xzLlwiKTtcbiAgfVxuICBpZiAoaGFzT3JDbGF1c2VzKSB7XG4gICAgcG9pbnRzIC09IDU7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiJ09yJyBjbGF1c2VzIHN1Z2dlc3QgYW1iaWd1aXR5LiBDaG9vc2Ugb25lIGNsZWFyIG9iamVjdGl2ZS5cIik7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IFwiZGVzYy5zaW5nbGVfb2JqZWN0aXZlXCIsXG4gICAgbGFiZWw6IFwiU2luZ2xlIG9iamVjdGl2ZVwiLFxuICAgIHBvaW50czogTWF0aC5tYXgoMCwgcG9pbnRzKSxcbiAgICBtYXg6IDIwLFxuICAgIHN0YXR1czogcG9pbnRzID09PSAyMCA/IFwiUEFTU1wiIDogcG9pbnRzID49IDEyID8gXCJXQVJOXCIgOiBcIkZBSUxcIixcbiAgICBub3RlczogdmlvbGF0aW9uc1swXSxcbiAgICB2aW9sYXRpb25zOiB2aW9sYXRpb25zLmxlbmd0aCA+IDAgPyBkZWR1cGUodmlvbGF0aW9ucykgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZhbERlc2NOb1N0ZXBzKGRlc2M6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIC8vIENoZWNrIGZvciBBTlkgbGlzdCBtYXJrZXJzIGFueXdoZXJlIGluIHRoZSBkZXNjcmlwdGlvbiAobm90IGp1c3QgYXQgbGluZSBzdGFydClcbiAgY29uc3QgaGFzTGlzdE1hcmtlcnMgPSAvKD86Wy0q4oCiXXxcXGQrWy4pXXxbYS16XVsuKV0pXFxzK1tBLVpdLy50ZXN0KGRlc2MpO1xuICBcbiAgLy8gQWxzbyBjaGVjayBmb3IgZGlyZWN0aXZlL2ltcGxlbWVudGF0aW9uIGxhbmd1YWdlXG4gIGNvbnN0IGhhc0ltcGxlbWVudGF0aW9uV29yZHMgPSAvXFxiKHRvIGFjaGlldmV8aW1wbGVtZW50fHN0ZXBzfGZvbGxvd2luZ3xwcm9jZWR1cmV8cHJvY2Vzcyk6L2kudGVzdChkZXNjKTtcbiAgXG4gIGNvbnN0IGhhc1N0ZXBzID0gaGFzTGlzdE1hcmtlcnMgfHwgaGFzSW1wbGVtZW50YXRpb25Xb3JkcztcbiAgY29uc3QgcG9pbnRzID0gaGFzU3RlcHMgPyAwIDogMjU7XG4gIGNvbnN0IHZpb2xhdGlvbnMgPSBoYXNTdGVwcyA/IFtcIkRlc2NyaXB0aW9uIGNvbnRhaW5zIGltcGxlbWVudGF0aW9uIHN0ZXBzLiBNb3ZlIHN0ZXBzIHRvIEd1aWRhbmNlIHNlY3Rpb24uIERlc2NyaXB0aW9uIHNob3VsZCBvbmx5IHN0YXRlIHRoZSBvdXRjb21lL3JlcXVpcmVtZW50LlwiXSA6IHVuZGVmaW5lZDtcbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IFwiZGVzYy5ub19zdGVwc1wiLFxuICAgIGxhYmVsOiBcIk5vIGltcGxlbWVudGF0aW9uIHN0ZXBzXCIsXG4gICAgcG9pbnRzLFxuICAgIG1heDogMjUsXG4gICAgc3RhdHVzOiBwb2ludHMgPT09IDI1ID8gXCJQQVNTXCIgOiBcIkZBSUxcIixcbiAgICBub3RlczogdmlvbGF0aW9ucz8uWzBdLFxuICAgIHZpb2xhdGlvbnNcbiAgfTtcbn1cblxuLy8gRklYICMxOiBDaGFuZ2UgbWluX3dvcmRzIHRvIDIwIGluc3RlYWQgb2YgMjVcbi8vIFVQREFURUQ6IERlc2NyaXB0aW9uIHdvcmQgY291bnQgMjAtNTAgKG5vdCAyMC0xMjApXG4vLyBGSVggMTogQ2hhbmdlIHdvcmQgY291bnQgdG8gMTUtNDVcbmZ1bmN0aW9uIGV2YWxEZXNjV29yZENvdW50KGRlc2M6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IHdvcmRzID0gZGVzYy50cmltKCkuc3BsaXQoL1xccysvKS5sZW5ndGg7XG4gIGNvbnN0IG1pbiA9IDE1OyAvLyBDaGFuZ2VkIGZyb20gMjBcbiAgY29uc3QgbWF4ID0gNDU7IC8vIENoYW5nZWQgZnJvbSA1MFxuICBjb25zdCB3aXRoaW5Cb3VuZHMgPSB3b3JkcyA+PSBtaW4gJiYgd29yZHMgPD0gbWF4O1xuICBsZXQgcG9pbnRzID0gMjA7XG4gIGNvbnN0IHZpb2xhdGlvbnM6IHN0cmluZ1tdID0gW107XG4gIFxuICBpZiAod29yZHMgPCBtaW4pIHtcbiAgICBwb2ludHMgLT0gMTA7XG4gICAgdmlvbGF0aW9ucy5wdXNoKGBUb28gYnJpZWYgKCR7d29yZHN9IHdvcmRzKS4gQWRkIGNsYXJpdHkuIEFpbSBmb3IgJHttaW59LSR7bWF4fSB3b3Jkcy5gKTtcbiAgfSBlbHNlIGlmICh3b3JkcyA+IG1heCkge1xuICAgIHBvaW50cyAtPSA4O1xuICAgIHZpb2xhdGlvbnMucHVzaChgVG9vIHZlcmJvc2UgKCR7d29yZHN9IHdvcmRzKS4gQmUgY29uY2lzZS4gQWltIGZvciAke21pbn0tJHttYXh9IHdvcmRzLmApO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBcImRlc2Mud29yZF9jb3VudFwiLFxuICAgIGxhYmVsOiBgV29yZCBjb3VudCAoJHttaW59LSR7bWF4fSlgLFxuICAgIHBvaW50czogd2l0aGluQm91bmRzID8gcG9pbnRzIDogTWF0aC5tYXgoMCwgcG9pbnRzKSxcbiAgICBtYXg6IDIwLFxuICAgIHN0YXR1czogd2l0aGluQm91bmRzID8gXCJQQVNTXCIgOiBwb2ludHMgPj0gMTIgPyBcIldBUk5cIiA6IFwiRkFJTFwiLFxuICAgIG5vdGVzOiB2aW9sYXRpb25zWzBdLFxuICAgIHZpb2xhdGlvbnM6IHZpb2xhdGlvbnMubGVuZ3RoID4gMCA/IHZpb2xhdGlvbnMgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuLy8gRklYICMyOiBJbXByb3ZlZCBhY3JvbnltIGRldGVjdGlvbiAtIGNoZWNrcyBib3RoIGJlZm9yZSBBTkQgYWZ0ZXJcbmZ1bmN0aW9uIGV2YWxEZXNjU3RhbmRhbG9uZUNsYXJpdHkoZGVzYzogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3QgaGFzVmFndWVUZXJtcyA9IC9cXGIoYXBwcm9wcmlhdGV8YWRlcXVhdGV8cmVhc29uYWJsZXxzdWZmaWNpZW50fHByb3BlcnxlZmZlY3RpdmUpXFxiL2kudGVzdChkZXNjKTtcbiAgXG4gIC8vIEZpbmQgYWNyb255bXMgdGhhdCBhcmUgTk9UIGV4cGFuZGVkIGFueXdoZXJlIG5lYXJieSAoYmVmb3JlIG9yIGFmdGVyKVxuICBjb25zdCBhY3JvbnltUGF0dGVybiA9IC9cXGIoW0EtWl17Mix9KVxcYi9nO1xuICBjb25zdCBhY3JvbnltcyA9IGRlc2MubWF0Y2goYWNyb255bVBhdHRlcm4pIHx8IFtdO1xuICBjb25zdCB1bmV4cGFuZGVkQWNyb255bXM6IHN0cmluZ1tdID0gW107XG4gIFxuICBmb3IgKGNvbnN0IGFjcm9ueW0gb2YgYWNyb255bXMpIHtcbiAgICAvLyBDaGVjayBpZiBhY3JvbnltIGlzIGV4cGFuZGVkIGluIHBhcmVudGhlc2VzIGFmdGVyIGl0OiBcIkRQTyAoRGF0YSBQcm90ZWN0aW9uIE9mZmljZXIpXCJcbiAgICBjb25zdCBleHBhbmRlZEFmdGVyID0gbmV3IFJlZ0V4cChgXFxcXGIke2Fjcm9ueW19XFxcXGJcXFxccypcXFxcKFteKV0rXFxcXClgKS50ZXN0KGRlc2MpO1xuICAgIC8vIENoZWNrIGlmIGFjcm9ueW0gaXMgaW4gcGFyZW50aGVzZXMgYWZ0ZXIgZXhwYW5zaW9uOiBcIkRhdGEgUHJvdGVjdGlvbiBPZmZpY2VyIChEUE8pXCJcbiAgICBjb25zdCBleHBhbmRlZEJlZm9yZSA9IG5ldyBSZWdFeHAoYFxcXFwoW14pXSpcXFxcYiR7YWNyb255bX1cXFxcYlteKV0qXFxcXClgKS50ZXN0KGRlc2MpO1xuICAgIFxuICAgIGlmICghZXhwYW5kZWRBZnRlciAmJiAhZXhwYW5kZWRCZWZvcmUpIHtcbiAgICAgIHVuZXhwYW5kZWRBY3Jvbnltcy5wdXNoKGFjcm9ueW0pO1xuICAgIH1cbiAgfVxuICBcbiAgbGV0IHBvaW50cyA9IDIwO1xuICBjb25zdCB2aW9sYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgaWYgKGhhc1ZhZ3VlVGVybXMpIHtcbiAgICBwb2ludHMgLT0gODtcbiAgICB2aW9sYXRpb25zLnB1c2goXCJBdm9pZCB2YWd1ZSBxdWFsaWZpZXJzIChhcHByb3ByaWF0ZS9hZGVxdWF0ZSkuIEJlIHNwZWNpZmljIGFib3V0IHJlcXVpcmVtZW50cy5cIik7XG4gIH1cbiAgaWYgKHVuZXhwYW5kZWRBY3Jvbnltcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgYWNyb255bSA9IHVuZXhwYW5kZWRBY3Jvbnltc1swXTtcbiAgICBwb2ludHMgLT0gNTtcbiAgICB2aW9sYXRpb25zLnB1c2goYEV4cGFuZCBhY3JvbnltIG9uIGZpcnN0IHVzZTogXCIke2Fjcm9ueW19XCIg4oaSIFwiRnVsbCBUZXJtICgke2Fjcm9ueW19KVwiYCk7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IFwiZGVzYy5zdGFuZGFsb25lX2NsYXJpdHlcIixcbiAgICBsYWJlbDogXCJTdGFuZGFsb25lIGNsYXJpdHlcIixcbiAgICBwb2ludHM6IE1hdGgubWF4KDAsIHBvaW50cyksXG4gICAgbWF4OiAyMCxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMjAgPyBcIlBBU1NcIiA6IHBvaW50cyA+PSAxMiA/IFwiV0FSTlwiIDogXCJGQUlMXCIsXG4gICAgbm90ZXM6IHZpb2xhdGlvbnNbMF0sXG4gICAgdmlvbGF0aW9uczogdmlvbGF0aW9ucy5sZW5ndGggPiAwID8gZGVkdXBlKHZpb2xhdGlvbnMpIDogdW5kZWZpbmVkXG4gIH07XG59XG5cbi8vID09PT09PT09PT0gR1VJREFOQ0UgUVVBTElUWSBDSEVDS1MgKDQwJSB3ZWlnaHQpID09PT09PT09PT1cblxuLy8gRklYICMzOiBDaGVjayBpZiBndWlkYW5jZSBTVEFSVFMgd2l0aCBhIGxpc3QgbWFya2VyIChub3QganVzdCBjb250YWlucyBpdClcbi8vIFVQREFURUQ6IE11Y2ggc3RyaWN0ZXIgcHJlYW1ibGUgZGV0ZWN0aW9uIC0gMCBwb2ludHMgaWYgbm8gcmVhbCBwcmVhbWJsZVxuLy8gVVBEQVRFRCBldmFsR3VpZGFuY2VQcmVhbWJsZSAtIE1vcmUgZmxleGlibGUgb2JqZWN0aXZlL3JhdGlvbmFsZSBkZXRlY3Rpb25cblxuLy8gVVBEQVRFRCBldmFsR3VpZGFuY2VQcmVhbWJsZSAtIE1vcmUgZmxleGlibGUgb2JqZWN0aXZlL3JhdGlvbmFsZSBkZXRlY3Rpb25cblxuLy8gVVBEQVRFRCBldmFsR3VpZGFuY2VQcmVhbWJsZSAtIE1vcmUgZmxleGlibGUgb2JqZWN0aXZlL3JhdGlvbmFsZSBkZXRlY3Rpb25cblxuZnVuY3Rpb24gZXZhbEd1aWRhbmNlUHJlYW1ibGUoZ3VpZGFuY2U6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IGxpbmVzID0gZ3VpZGFuY2Uuc3BsaXQoJ1xcbicpLmZpbHRlcihsID0+IGwudHJpbSgpKTtcbiAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCJndWlkLnByZWFtYmxlXCIsXG4gICAgICBsYWJlbDogXCJQcmVhbWJsZSAod2hhdCArIHdoeSlcIixcbiAgICAgIHBvaW50czogMCxcbiAgICAgIG1heDogMzAsXG4gICAgICBzdGF0dXM6IFwiRkFJTFwiLFxuICAgICAgbm90ZXM6IFwiR3VpZGFuY2UgaXMgZW1wdHlcIixcbiAgICAgIHZpb2xhdGlvbnM6IFtcIkFkZCBndWlkYW5jZSB3aXRoIGEgcHJlYW1ibGUgZXhwbGFpbmluZyBvYmplY3RpdmUgYW5kIHJhdGlvbmFsZVwiXVxuICAgIH07XG4gIH1cbiAgXG4gIC8vIENoZWNrIGlmIEZJUlNUIGxpbmUgc3RhcnRzIHdpdGggYSBsaXN0IG1hcmtlciBvciBkaXJlY3RpdmUgdmVyYlxuICBjb25zdCBmaXJzdExpbmUgPSBsaW5lc1swXS50cmltKCk7XG4gIGNvbnN0IHN0YXJ0c1dpdGhMaXN0ID0gL14oPzpbLSrigKJdfFxcZCtbLildfFthLXpdWy4pXSlcXHMrLy50ZXN0KGZpcnN0TGluZSk7XG4gIGNvbnN0IHN0YXJ0c1dpdGhEaXJlY3RpdmUgPSAvXihkZXBsb3l8aW1wbGVtZW50fGNvbmZpZ3VyZXxtb25pdG9yfHJldmlld3xlc3RhYmxpc2h8Y3JlYXRlfG1haW50YWlufGVuYWJsZSlcXGIvaS50ZXN0KGZpcnN0TGluZSk7XG4gIFxuICAvLyBFeHRyYWN0IHByZWFtYmxlICh0ZXh0IGJlZm9yZSBmaXJzdCBsaXN0IG1hcmtlcilcbiAgY29uc3QgcHJlYW1ibGVNYXRjaCA9IGd1aWRhbmNlLm1hdGNoKC9eKFtcXHNcXFNdKz8pKD89XFxuXFxzKig/OlstKuKAol18XFxkK1suKV18W2Etel1bLildKVxccyspLyk7XG4gIGNvbnN0IHByZWFtYmxlID0gcHJlYW1ibGVNYXRjaCA/IHByZWFtYmxlTWF0Y2hbMV0udHJpbSgpIDogZ3VpZGFuY2Uuc3Vic3RyaW5nKDAsIDQwMCk7XG4gIFxuICAvLyDinIUgRklYRUQ6IE1vcmUgZmxleGlibGUgb2JqZWN0aXZlIGRldGVjdGlvblxuICAvLyBOT1cgQUNDRVBUUzpcbiAgLy8gLSBcInRvIGVzdGFibGlzaFwiIChvcmlnaW5hbClcbiAgLy8gLSBcInNob3VsZCBlc3RhYmxpc2hcIiwgXCJtdXN0IGRlZmluZVwiIChtb2RhbCArIHZlcmIpXG4gIC8vIC0gXCJhaW1zIHRvXCIsIFwiZGVzaWduZWQgdG9cIiwgZXRjLlxuICAgY29uc3QgaGFzT2JqZWN0aXZlID0gL1xcYihvYmplY3RpdmV8cHVycG9zZXxnb2FsfGFpbXM/XFxzK3RvfGludGVuZGVkXFxzK3RvfGRlc2lnbmVkXFxzK3RvfHRvXFxzKyg/OmVuc3VyZXxlc3RhYmxpc2h8c3VwcG9ydHxkZWZpbmV8Y3JlYXRlfG1haW50YWlufGltcGxlbWVudCl8KD86c2hvdWxkfG11c3R8d2lsbClcXHMrKD86ZXN0YWJsaXNofGRlZmluZXxjcmVhdGV8ZW5zdXJlfHN1cHBvcnR8bWFpbnRhaW58aW1wbGVtZW50KSlcXGIvaS50ZXN0KHByZWFtYmxlKTtcbiAgLy8g4pyFIEZJWEVEOiBNb3JlIGZsZXhpYmxlIHJhdGlvbmFsZSBkZXRlY3Rpb25cbiAgLy8gTk9XIEFDQ0VQVFM6XG4gIC8vIC0gXCJ0byBwcm9tb3RlXCIgKG9yaWdpbmFsKVxuICAvLyAtIFwicHJvbW90ZXNcIiwgXCJlbmFibGVzXCIsIFwic3VwcG9ydHNcIiAoc3RhbmRhbG9uZSB2ZXJicylcbiAgLy8gLSBcImltcG9ydGFudFwiLCBcImNyaXRpY2FsXCIsIFwiYmVjYXVzZVwiIChleGlzdGluZylcbiAgIGNvbnN0IGhhc1JhdGlvbmFsZSA9IC9cXGIocmF0aW9uYWxlfGJlY2F1c2V8aW1wb3J0YW50fGNyaXRpY2FsfG5lY2Vzc2FyeXxlc3NlbnRpYWx8dG9cXHMrKD86c3VwcG9ydHxlbmFibGV8aGVscHxhbGxvd3xwcm90ZWN0fHByZXZlbnR8ZW5zdXJlfG1haW50YWlufHByb21vdGUpfCg/OnByb21vdGVzP3xlbmFibGVzP3xzdXBwb3J0cz98ZW5zdXJlcz98bWFpbnRhaW5zP3xoZWxwcz98YWxsb3dzP3xwcmV2ZW50cz98cHJvdGVjdHM/KVxcYikvaS50ZXN0KHByZWFtYmxlKTtcbiAgLy8gUHJlYW1ibGUgc2hvdWxkIGJlIHN1YnN0YW50aWFsIChhdCBsZWFzdCAxNSB3b3JkcylcbiAgY29uc3QgcHJlYW1ibGVXb3JkcyA9IHByZWFtYmxlLnNwbGl0KC9cXHMrLykubGVuZ3RoO1xuICBjb25zdCBoYXNTdWJzdGFudGlhbFByZWFtYmxlID0gcHJlYW1ibGVXb3JkcyA+PSAxNTtcbiAgXG4gIGxldCBwb2ludHMgPSAzMDtcbiAgY29uc3QgdmlvbGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIC8vIElmIGd1aWRhbmNlIHN0YXJ0cyB3aXRoIGEgbGlzdCBvciBkaXJlY3RpdmUsIHRoZXJlJ3Mgbm8gcHJlYW1ibGUgLSBzY29yZSAwXG4gIGlmIChzdGFydHNXaXRoTGlzdCB8fCBzdGFydHNXaXRoRGlyZWN0aXZlKSB7XG4gICAgcG9pbnRzID0gMDtcbiAgICB2aW9sYXRpb25zLnB1c2goXCJObyBwcmVhbWJsZSBmb3VuZC4gQmVnaW4gd2l0aCAyLTMgc2VudGVuY2VzIGV4cGxhaW5pbmcgd2hhdCB0aGlzIGNvbnRyb2wgYWNoaWV2ZXMgYW5kIHdoeSBpdCBtYXR0ZXJzIGJlZm9yZSBsaXN0aW5nIHN0ZXBzLlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwiZ3VpZC5wcmVhbWJsZVwiLFxuICAgICAgbGFiZWw6IFwiUHJlYW1ibGUgKHdoYXQgKyB3aHkpXCIsXG4gICAgICBwb2ludHM6IDAsXG4gICAgICBtYXg6IDMwLFxuICAgICAgc3RhdHVzOiBcIkZBSUxcIixcbiAgICAgIG5vdGVzOiB2aW9sYXRpb25zWzBdLFxuICAgICAgdmlvbGF0aW9uc1xuICAgIH07XG4gIH1cbiAgXG4gIC8vIE90aGVyd2lzZSwgZXZhbHVhdGUgcHJlYW1ibGUgcXVhbGl0eVxuICBpZiAoIWhhc1N1YnN0YW50aWFsUHJlYW1ibGUpIHtcbiAgICBwb2ludHMgLT0gMTI7XG4gICAgdmlvbGF0aW9ucy5wdXNoKGBQcmVhbWJsZSB0b28gYnJpZWYgKCR7cHJlYW1ibGVXb3Jkc30gd29yZHMpLiBQcm92aWRlIGF0IGxlYXN0IDItMyBzZW50ZW5jZXMgKDE1KyB3b3JkcykgZXhwbGFpbmluZyB0aGUgY29udHJvbCdzIHB1cnBvc2UuYCk7XG4gIH1cbiAgaWYgKCFoYXNPYmplY3RpdmUpIHtcbiAgICBwb2ludHMgLT0gMTA7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiUHJlYW1ibGUgbXVzdCBzdGF0ZSB0aGUgb2JqZWN0aXZlICh3aGF0IHRoaXMgY29udHJvbCBhY2hpZXZlcylcIik7XG4gIH1cbiAgaWYgKCFoYXNSYXRpb25hbGUpIHtcbiAgICBwb2ludHMgLT0gODtcbiAgICB2aW9sYXRpb25zLnB1c2goXCJQcmVhbWJsZSBtdXN0IGV4cGxhaW4gcmF0aW9uYWxlICh3aHkgdGhpcyBjb250cm9sIG1hdHRlcnMpXCIpO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBcImd1aWQucHJlYW1ibGVcIixcbiAgICBsYWJlbDogXCJQcmVhbWJsZSAod2hhdCArIHdoeSlcIixcbiAgICBwb2ludHM6IE1hdGgubWF4KDAsIHBvaW50cyksXG4gICAgbWF4OiAzMCxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMzAgPyBcIlBBU1NcIiA6IHBvaW50cyA+PSAyMCA/IFwiV0FSTlwiIDogXCJGQUlMXCIsXG4gICAgbm90ZXM6IHZpb2xhdGlvbnNbMF0sXG4gICAgdmlvbGF0aW9uczogdmlvbGF0aW9ucy5sZW5ndGggPiAwID8gZGVkdXBlKHZpb2xhdGlvbnMpIDogdW5kZWZpbmVkXG4gIH07XG59XG5cblxuZnVuY3Rpb24gZXZhbEd1aWRhbmNlU3RydWN0dXJlZFN0ZXBzKGd1aWRhbmNlOiBzdHJpbmcpOiBTY29yaW5nQ2hlY2tSZXN1bHQge1xuICBjb25zdCBoYXNTdHJ1Y3R1cmUgPSBsb29rc1N0cnVjdHVyZWQoZ3VpZGFuY2UpO1xuICBjb25zdCBzdGVwcyA9IGV4dHJhY3RTdGVwcyhndWlkYW5jZSk7XG4gIGNvbnN0IHN0ZXBDb3VudCA9IHN0ZXBzLmxlbmd0aDtcbiAgY29uc3QgbWluID0gc3BlYy5ydWxlcy5ndWlkYW5jZS5zdGVwc19taW4gfHwgMjtcbiAgY29uc3QgbWF4ID0gc3BlYy5ydWxlcy5ndWlkYW5jZS5zdGVwc19tYXggfHwgODtcbiAgXG4gIGxldCBwb2ludHMgPSAzMDtcbiAgY29uc3QgdmlvbGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIGlmICghaGFzU3RydWN0dXJlKSB7XG4gICAgcG9pbnRzIC09IDE1O1xuICAgIHZpb2xhdGlvbnMucHVzaChcIkZvcm1hdCBzdGVwcyBhcyBhIG51bWJlcmVkIG9yIGJ1bGxldGVkIGxpc3QgKGUuZy4sIDEuIFN0ZXAgb25lOyAyLiBTdGVwIHR3bylcIik7XG4gIH1cbiAgaWYgKHN0ZXBDb3VudCA8IG1pbikge1xuICAgIHBvaW50cyAtPSAxMDtcbiAgICB2aW9sYXRpb25zLnB1c2goYFRvbyBmZXcgc3RlcHMgKCR7c3RlcENvdW50fSkuIFByb3ZpZGUgJHttaW59LSR7bWF4fSBhY3Rpb25hYmxlIHN0ZXBzLmApO1xuICB9IGVsc2UgaWYgKHN0ZXBDb3VudCA+IG1heCkge1xuICAgIHBvaW50cyAtPSA4O1xuICAgIHZpb2xhdGlvbnMucHVzaChgVG9vIG1hbnkgc3RlcHMgKCR7c3RlcENvdW50fSkuIENvbnNvbGlkYXRlIHRvICR7bWlufS0ke21heH0ga2V5IHN0ZXBzLmApO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBcImd1aWQuc3RydWN0dXJlZF9zdGVwc1wiLFxuICAgIGxhYmVsOiBgU3RydWN0dXJlZCBzdGVwcyAoJHttaW59LSR7bWF4fSlgLFxuICAgIHBvaW50czogTWF0aC5tYXgoMCwgcG9pbnRzKSxcbiAgICBtYXg6IDMwLFxuICAgIHN0YXR1czogcG9pbnRzID09PSAzMCA/IFwiUEFTU1wiIDogcG9pbnRzID49IDE4ID8gXCJXQVJOXCIgOiBcIkZBSUxcIixcbiAgICBub3RlczogdmlvbGF0aW9uc1swXSxcbiAgICB2aW9sYXRpb25zOiB2aW9sYXRpb25zLmxlbmd0aCA+IDAgPyBkZWR1cGUodmlvbGF0aW9ucykgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuLy8gRklYICM0OiBCZXR0ZXIgYWN0aW9uIHZlcmIgZGV0ZWN0aW9uIGFmdGVyIGxpc3QgbWFya2Vyc1xuZnVuY3Rpb24gZXZhbEd1aWRhbmNlQWN0aW9uYWJsZShndWlkYW5jZTogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3Qgc3RlcHMgPSBleHRyYWN0U3RlcHMoZ3VpZGFuY2UpO1xuICBcbiAgLy8gSWYgd2UgaGF2ZSBzdHJ1Y3R1cmVkIHN0ZXBzLCBjaGVjayBpZiB0aGV5IHN0YXJ0IHdpdGggYWN0aW9uIHZlcmJzXG4gIGlmIChzdGVwcy5sZW5ndGggPj0gMikge1xuICAgIGNvbnN0IGFjdGlvbmFibGVTdGVwcyA9IHN0ZXBzLmZpbHRlcihzdGVwID0+IHtcbiAgICAgIC8vIFJlbW92ZSBsaXN0IG1hcmtlcnNcbiAgICAgIGNvbnN0IHN0ZXBUZXh0ID0gc3RlcC5yZXBsYWNlKC9eXFxzKig/OlstKuKAol18XFxkK1suKV18W2Etel1bLildKVxccyovLCAnJykudHJpbSgpO1xuICAgICAgY29uc3QgZmlyc3RXb3JkID0gc3RlcFRleHQuc3BsaXQoL1xccysvKVswXTtcbiAgICAgIFxuICAgICAgLy8gSGV1cmlzdGljOiBBY3Rpb25hYmxlIGlmIGZpcnN0IHdvcmQgaXM6XG4gICAgICAvLyAxLiBDYXBpdGFsaXplZCAoaW1wZXJhdGl2ZSBmb3JtKVxuICAgICAgLy8gMi4gTm90IGEgbW9kYWwvYXJ0aWNsZVxuICAgICAgLy8gMy4gQXQgbGVhc3QgMyBjaGFyYWN0ZXJzIGxvbmdcbiAgICAgIGNvbnN0IGlzQ2FwaXRhbGl6ZWQgPSAvXltBLVpdLy50ZXN0KGZpcnN0V29yZCk7XG4gICAgICBjb25zdCBub3RNb2RhbE9yQXJ0aWNsZSA9ICEvXih0aGV8YXxhbnxzaG91bGR8bXVzdHx3aWxsfHNoYWxsfG1heXxjYW58Y291bGR8d291bGQpJC9pLnRlc3QoZmlyc3RXb3JkKTtcbiAgICAgIGNvbnN0IGxvbmdFbm91Z2ggPSBmaXJzdFdvcmQubGVuZ3RoID49IDM7XG4gICAgICBcbiAgICAgIHJldHVybiBpc0NhcGl0YWxpemVkICYmIG5vdE1vZGFsT3JBcnRpY2xlICYmIGxvbmdFbm91Z2g7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgcmF0aW8gPSBhY3Rpb25hYmxlU3RlcHMubGVuZ3RoIC8gc3RlcHMubGVuZ3RoO1xuICAgIGxldCBwb2ludHMgPSBNYXRoLnJvdW5kKDIwICogcmF0aW8pO1xuICAgIGNvbnN0IHZpb2xhdGlvbnMgPSByYXRpbyA8IDEuMCBcbiAgICAgID8gW2Ake3N0ZXBzLmxlbmd0aCAtIGFjdGlvbmFibGVTdGVwcy5sZW5ndGh9IHN0ZXAocykgZG9uJ3Qgc3RhcnQgd2l0aCBhY3Rpb24gdmVyYnMuIEJlZ2luIHdpdGg6IGltcGxlbWVudCwgY29uZmlndXJlLCByZXZpZXcsIG1vbml0b3IsIGV0Yy5gXSBcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpZDogXCJndWlkLmFjdGlvbmFibGVcIixcbiAgICAgIGxhYmVsOiBcIlN0ZXBzIGFyZSBhY3Rpb25hYmxlXCIsXG4gICAgICBwb2ludHMsXG4gICAgICBtYXg6IDIwLFxuICAgICAgc3RhdHVzOiBwb2ludHMgPT09IDIwID8gXCJQQVNTXCIgOiBwb2ludHMgPj0gMTQgPyBcIldBUk5cIiA6IFwiRkFJTFwiLFxuICAgICAgbm90ZXM6IHZpb2xhdGlvbnM/LlswXSxcbiAgICAgIHZpb2xhdGlvbnNcbiAgICB9O1xuICB9XG4gIFxuICAvLyBGYWxsYmFjazogSWYgbGVzcyB0aGFuIDIgc3RlcHMsIGNoZWNrIGZvciBhY3Rpb24gdmVyYnMgaW4gZ2VuZXJhbCB0ZXh0XG4gIGNvbnN0IGFjdGlvblZlcmJzID0gL1xcYihpbXBsZW1lbnR8Y29uZmlndXJlfHJldmlld3xtb25pdG9yfGRvY3VtZW50fGRlZmluZXxlc3RhYmxpc2h8bWFpbnRhaW58ZW5hYmxlfGNyZWF0ZXxkZXZlbG9wfGNvbmR1Y3R8cGVyZm9ybXx2ZXJpZnl8dmFsaWRhdGV8YXNzZXNzfGlkZW50aWZ5fGVuc3VyZXxkZXNpZ25hdGV8YXBwb2ludHxkZXBsb3l8aW5zdGFsbHx1cGRhdGV8dHJhY2t8cmVwb3J0fGNvbW11bmljYXRlfHB1Ymxpc2h8cmVjb3JkfGVzY2FsYXRlfGludmVzdGlnYXRlfHJlbWVkaWF0ZXxkaXNhYmxlKVxcYi9naTtcbiAgY29uc3QgbWF0Y2hlcyA9IGd1aWRhbmNlLm1hdGNoKGFjdGlvblZlcmJzKTtcbiAgY29uc3QgYWN0aW9uVmVyYkNvdW50ID0gbWF0Y2hlcyA/IG1hdGNoZXMubGVuZ3RoIDogMDtcbiAgXG4gIGxldCBwb2ludHMgPSAyMDtcbiAgY29uc3QgdmlvbGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIGlmIChhY3Rpb25WZXJiQ291bnQgPT09IDApIHtcbiAgICBwb2ludHMgPSAwO1xuICAgIHZpb2xhdGlvbnMucHVzaChcIk5vIGFjdGlvbiB2ZXJicyBmb3VuZC4gVXNlIGFjdGlvbmFibGUgbGFuZ3VhZ2UgKGltcGxlbWVudCwgY29uZmlndXJlLCByZXZpZXcsIG1vbml0b3IsIGV0Yy4pXCIpO1xuICB9IGVsc2UgaWYgKGFjdGlvblZlcmJDb3VudCA8IDIpIHtcbiAgICBwb2ludHMgPSAxMDtcbiAgICB2aW9sYXRpb25zLnB1c2goXCJUb28gZmV3IGFjdGlvbmFibGUgaW5zdHJ1Y3Rpb25zLiBQcm92aWRlIGF0IGxlYXN0IDItMyBhY3Rpb24tb3JpZW50ZWQgc3RlcHMuXCIpO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBcImd1aWQuYWN0aW9uYWJsZVwiLFxuICAgIGxhYmVsOiBcIlN0ZXBzIGFyZSBhY3Rpb25hYmxlXCIsXG4gICAgcG9pbnRzLFxuICAgIG1heDogMjAsXG4gICAgc3RhdHVzOiBwb2ludHMgPT09IDIwID8gXCJQQVNTXCIgOiBwb2ludHMgPj0gMTQgPyBcIldBUk5cIiA6IFwiRkFJTFwiLFxuICAgIG5vdGVzOiB2aW9sYXRpb25zWzBdLFxuICAgIHZpb2xhdGlvbnM6IHZpb2xhdGlvbnMubGVuZ3RoID4gMCA/IHZpb2xhdGlvbnMgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuLy8gVVBEQVRFRDogRXZhbHVhdGUgdGVuc2Uvdm9pY2Ugb24gYWN0dWFsIGNvbnRlbnQsIG5vdCBkZXBlbmRlbnQgb24gc3RlcHNcbmZ1bmN0aW9uIGV2YWxHdWlkYW5jZVByZXNlbnRBY3RpdmUoZ3VpZGFuY2U6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIC8vIExvb2sgZm9yIHByZXNlbnQgdGVuc2UgYWN0aW9uIHZlcmJzIChpbXBlcmF0aXZlcykgaW4gdGhlIGd1aWRhbmNlXG4gIGNvbnN0IHByZXNlbnRJbXBlcmF0aXZlcyA9IC9cXGIoaW1wbGVtZW50fGNvbmZpZ3VyZXxyZXZpZXd8bW9uaXRvcnxkb2N1bWVudHxkZWZpbmV8ZXN0YWJsaXNofG1haW50YWlufGVuYWJsZXxjcmVhdGV8ZGV2ZWxvcHxjb25kdWN0fHBlcmZvcm18dmVyaWZ5fHZhbGlkYXRlfGFzc2Vzc3xpZGVudGlmeXxkZXNpZ25hdGV8YXBwb2ludClcXGIvaS50ZXN0KGd1aWRhbmNlKTtcbiAgXG4gIC8vIENoZWNrIGZvciBwYXN0IHRlbnNlICh3cm9uZylcbiAgY29uc3QgaGFzUGFzdFRlbnNlID0gL1xcYihjb25maWd1cmVkfHJldmlld2VkfGltcGxlbWVudGVkfGVzdGFibGlzaGVkfGNyZWF0ZWR8ZGV2ZWxvcGVkfG1haW50YWluZWR8ZW5hYmxlZHxjb25kdWN0ZWR8cGVyZm9ybWVkKVxcYi9pLnRlc3QoZ3VpZGFuY2UpO1xuICBcbiAgLy8gQ2hlY2sgZm9yIHBhc3NpdmUgdm9pY2UgaW4gZ3VpZGFuY2UgKHdyb25nIC0gc2hvdWxkIGJlIGFjdGl2ZSBpbXBlcmF0aXZlcylcbiAgY29uc3QgaGFzUGFzc2l2ZSA9IC9cXGIoaXN8YXJlfGJlKVxccysoPzpjb25maWd1cmVkfHJldmlld2VkfGltcGxlbWVudGVkfGVzdGFibGlzaGVkfG1haW50YWluZWR8ZW5hYmxlZHxjb25kdWN0ZWR8cGVyZm9ybWVkKVxcYi9pLnRlc3QoZ3VpZGFuY2UpO1xuICBcbiAgbGV0IHBvaW50cyA9IDIwO1xuICBjb25zdCB2aW9sYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgaWYgKCFwcmVzZW50SW1wZXJhdGl2ZXMpIHtcbiAgICBwb2ludHMgLT0gMTA7XG4gICAgdmlvbGF0aW9ucy5wdXNoKFwiVXNlIHByZXNlbnQgdGVuc2UgYWN0aW9uIHZlcmJzIChlLmcuLCAnQ29uZmlndXJlLi4uJywgJ1Jldmlldy4uLicsICdNb25pdG9yLi4uJylcIik7XG4gIH1cbiAgaWYgKGhhc1Bhc3RUZW5zZSkge1xuICAgIHBvaW50cyAtPSA4O1xuICAgIHZpb2xhdGlvbnMucHVzaChcIkF2b2lkIHBhc3QgdGVuc2UgKGUuZy4sICdjb25maWd1cmVkJykuIFVzZSBwcmVzZW50IHRlbnNlIGltcGVyYXRpdmVzIChlLmcuLCAnQ29uZmlndXJlJylcIik7XG4gIH1cbiAgaWYgKGhhc1Bhc3NpdmUpIHtcbiAgICBwb2ludHMgLT0gNztcbiAgICB2aW9sYXRpb25zLnB1c2goXCJVc2UgYWN0aXZlIHZvaWNlIGZvciBzdGVwcyAoZS5nLiwgJ1JldmlldyBhY2Nlc3MgbG9ncycgbm90ICdBY2Nlc3MgbG9ncyBhcmUgcmV2aWV3ZWQnKVwiKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpZDogXCJndWlkLnByZXNlbnRfYWN0aXZlXCIsXG4gICAgbGFiZWw6IFwiUHJlc2VudCB0ZW5zZSArIGFjdGl2ZSB2b2ljZVwiLFxuICAgIHBvaW50czogTWF0aC5tYXgoMCwgcG9pbnRzKSxcbiAgICBtYXg6IDIwLFxuICAgIHN0YXR1czogcG9pbnRzID09PSAyMCA/IFwiUEFTU1wiIDogcG9pbnRzID49IDEyID8gXCJXQVJOXCIgOiBcIkZBSUxcIixcbiAgICBub3RlczogdmlvbGF0aW9uc1swXSxcbiAgICB2aW9sYXRpb25zOiB2aW9sYXRpb25zLmxlbmd0aCA+IDAgPyBkZWR1cGUodmlvbGF0aW9ucykgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZhbEd1aWRhbmNlVGVjaEFnbm9zdGljKGd1aWRhbmNlOiBzdHJpbmcpOiBTY29yaW5nQ2hlY2tSZXN1bHQge1xuICBjb25zdCB2ZW5kb3JNYXRjaGVzID0gZ3VpZGFuY2UubWF0Y2goL1xcYihhd3N8YXp1cmV8Z2NwfGdvb2dsZVxccytjbG91ZHxva3RhfHNlcnZpY2Vub3d8Y2lzY298cGFsb1xccyphbHRvfGZvcnRpbmV0fHNwbHVua3xkYXRhZG9nfHNhbGVzZm9yY2V8c25vd2ZsYWtlfGNyb3dkc3RyaWtlfG1pY3Jvc29mdHxvcmFjbGV8aWJtfHNhcClcXGIvZ2kpIHx8IFtdO1xuICBjb25zdCBoYXNWZW5kb3IgPSB2ZW5kb3JNYXRjaGVzLmxlbmd0aCA+IDA7XG4gIGNvbnN0IHBvaW50cyA9IGhhc1ZlbmRvciA/IDEwIDogMjA7XG4gIFxuICBjb25zdCB1bmlxdWVWZW5kb3JzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZlbmRvck1hdGNoZXMubWFwKHYgPT4gdi50b0xvd2VyQ2FzZSgpKSkpO1xuICBjb25zdCB2ZW5kb3JMaXN0ID0gdW5pcXVlVmVuZG9ycy5qb2luKCcsICcpO1xuICBcbiAgY29uc3QgdmlvbGF0aW9ucyA9IGhhc1ZlbmRvciBcbiAgICA/IFtgUmVtb3ZlIHZlbmRvci90b29sIG5hbWVzIChmb3VuZCAke3ZlbmRvck1hdGNoZXMubGVuZ3RofTogXCIke3ZlbmRvckxpc3R9XCIpLiBVc2UgZ2VuZXJpYyB0ZXJtcyAoZS5nLiwgXCJpZGVudGl0eSBtYW5hZ2VtZW50IHN5c3RlbVwiIG5vdCBcIk9rdGFcIilgXSBcbiAgICA6IHVuZGVmaW5lZDtcbiAgICBcbiAgcmV0dXJuIHtcbiAgICBpZDogXCJndWlkLnRlY2hfYWdub3N0aWNcIixcbiAgICBsYWJlbDogXCJUZWNobm9sb2d5LWFnbm9zdGljXCIsXG4gICAgcG9pbnRzLFxuICAgIG1heDogMjAsXG4gICAgc3RhdHVzOiBwb2ludHMgPT09IDIwID8gXCJQQVNTXCIgOiBcIldBUk5cIixcbiAgICBub3RlczogdmlvbGF0aW9ucz8uWzBdLFxuICAgIHZpb2xhdGlvbnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZhbEd1aWRhbmNlUm9sZU5ldXRyYWwoZ3VpZGFuY2U6IHN0cmluZyk6IFNjb3JpbmdDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IGhhc1JvbGVSZWYgPSBST0xFX1NQRUNJRklDLnRlc3QoZ3VpZGFuY2UpO1xuICBjb25zdCBwb2ludHMgPSBoYXNSb2xlUmVmID8gMTAgOiAyMDtcbiAgY29uc3QgdmlvbGF0aW9ucyA9IGhhc1JvbGVSZWYgPyBbXCJBdm9pZCByb2xlLXNwZWNpZmljIHJlZmVyZW5jZXMgKGUuZy4sICdzZWN1cml0eSB0ZWFtJykuIEtlZXAgZ3VpZGFuY2UgYXBwbGljYWJsZSBhY3Jvc3Mgb3JnYW5pemF0aW9uYWwgc3RydWN0dXJlcy5cIl0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgaWQ6IFwiZ3VpZC5yb2xlX25ldXRyYWxcIixcbiAgICBsYWJlbDogXCJSb2xlLW5ldXRyYWxcIixcbiAgICBwb2ludHMsXG4gICAgbWF4OiAyMCxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMjAgPyBcIlBBU1NcIiA6IFwiV0FSTlwiLFxuICAgIG5vdGVzOiB2aW9sYXRpb25zPy5bMF0sXG4gICAgdmlvbGF0aW9uc1xuICB9O1xufVxuXG5mdW5jdGlvbiBldmFsR3VpZGFuY2VOb0phcmdvbihndWlkYW5jZTogc3RyaW5nKTogU2NvcmluZ0NoZWNrUmVzdWx0IHtcbiAgY29uc3QgaGFzSmFyZ29uID0gSkFSR09OX1dPUkRTLnRlc3QoZ3VpZGFuY2UpO1xuICBjb25zdCBwb2ludHMgPSBoYXNKYXJnb24gPyAxMiA6IDIwO1xuICBjb25zdCBqYXJnb24gPSBndWlkYW5jZS5tYXRjaChKQVJHT05fV09SRFMpPy5bMF07XG4gIGNvbnN0IHZpb2xhdGlvbnMgPSBoYXNKYXJnb24gPyBbYFJlcGxhY2UgamFyZ29uIFwiJHtqYXJnb259XCIgd2l0aCBwbGFpbiBsYW5ndWFnZWBdIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIGlkOiBcImd1aWQubm9famFyZ29uXCIsXG4gICAgbGFiZWw6IFwiUGxhaW4gbGFuZ3VhZ2UgKG5vIGphcmdvbilcIixcbiAgICBwb2ludHMsXG4gICAgbWF4OiAyMCxcbiAgICBzdGF0dXM6IHBvaW50cyA9PT0gMjAgPyBcIlBBU1NcIiA6IFwiV0FSTlwiLFxuICAgIG5vdGVzOiB2aW9sYXRpb25zPy5bMF0sXG4gICAgdmlvbGF0aW9uc1xuICB9O1xufVxuXG4vLyA9PT09PT09PT09IEFHR1JFR0FUSU9OID09PT09PT09PT1cblxuZnVuY3Rpb24gYWdncmVnYXRlRGltZW5zaW9uKFxuICBrZXk6IHN0cmluZyxcbiAgbGFiZWw6IHN0cmluZyxcbiAgd2VpZ2h0OiBudW1iZXIsXG4gIGNoZWNrczogU2NvcmluZ0NoZWNrUmVzdWx0W11cbik6IERpbWVuc2lvblJlc3VsdCB7XG4gIGNvbnN0IHRvdGFsTWF4ID0gY2hlY2tzLnJlZHVjZSgoc3VtLCBjKSA9PiBzdW0gKyBjLm1heCwgMCk7XG4gIGNvbnN0IHRvdGFsUG9pbnRzID0gY2hlY2tzLnJlZHVjZSgoc3VtLCBjKSA9PiBzdW0gKyBjLnBvaW50cywgMCk7XG4gIGNvbnN0IHNjb3JlID0gdG90YWxNYXggPiAwID8gTWF0aC5yb3VuZCgodG90YWxQb2ludHMgLyB0b3RhbE1heCkgKiAxMDApIDogMDtcbiAgXG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIGxhYmVsLFxuICAgIHNjb3JlOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHNjb3JlKSksXG4gICAgbWF4OiAxMDAsXG4gICAgd2VpZ2h0LFxuICAgIGNoZWNrc1xuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZE1lc3NhZ2VzKC4uLmRpbXM6IERpbWVuc2lvblJlc3VsdFtdKTogeyBsZXZlbDogXCJQQVNTXCIgfCBcIldBUk5cIiB8IFwiRkFJTFwiOyB0ZXh0OiBzdHJpbmcgfVtdIHtcbiAgY29uc3QgbXNnczogeyBsZXZlbDogXCJQQVNTXCIgfCBcIldBUk5cIiB8IFwiRkFJTFwiOyB0ZXh0OiBzdHJpbmcgfVtdID0gW107XG4gIFxuICBmb3IgKGNvbnN0IGRpbSBvZiBkaW1zKSB7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiBkaW0uY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2suc3RhdHVzID09PSBcIkZBSUxcIiAmJiBjaGVjay5ub3Rlcykge1xuICAgICAgICBtc2dzLnB1c2goeyBsZXZlbDogXCJGQUlMXCIsIHRleHQ6IGNoZWNrLm5vdGVzIH0pO1xuICAgICAgfSBlbHNlIGlmIChjaGVjay5zdGF0dXMgPT09IFwiV0FSTlwiICYmIGNoZWNrLm5vdGVzKSB7XG4gICAgICAgIG1zZ3MucHVzaCh7IGxldmVsOiBcIldBUk5cIiwgdGV4dDogY2hlY2subm90ZXMgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gbXNncy5zbGljZSgwLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3VnZ2VzdGlvbnMoLi4uZGltczogRGltZW5zaW9uUmVzdWx0W10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHN1Z2dlc3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBhZGQgPSAoczogc3RyaW5nKSA9PiB7IGlmIChzICYmICFzdWdnZXN0aW9ucy5pbmNsdWRlcyhzKSkgc3VnZ2VzdGlvbnMucHVzaChzKTsgfTtcbiAgXG4gIC8vIENvbGxlY3QgdW5pcXVlIHN1Z2dlc3Rpb25zIGZyb20gdmlvbGF0aW9uc1xuICBmb3IgKGNvbnN0IGRpbSBvZiBkaW1zKSB7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiBkaW0uY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sudmlvbGF0aW9ucykge1xuICAgICAgICBjaGVjay52aW9sYXRpb25zLmZvckVhY2godiA9PiBhZGQodikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHN1Z2dlc3Rpb25zLnNsaWNlKDAsIDgpO1xufVxuXG4vLyA9PT09PT09PT09IE1BSU4gU0NPUkVSID09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjb3JlQ29udHJvbChpdGVtOiBDb250cm9sSW5wdXQpOiBDb250cm9sU2NvcmVSZXNwb25zZSB7XG4gIGNvbnN0IGlkID0gKGl0ZW0uaWQgfHwgXCJcIikudHJpbSgpO1xuICBjb25zdCBuYW1lID0gKGl0ZW0ubmFtZSB8fCBcIlwiKS50cmltKCk7XG4gIGNvbnN0IGRlc2MgPSAoaXRlbS5kZXNjcmlwdGlvbiB8fCBcIlwiKS50cmltKCk7XG4gIGNvbnN0IGd1aWQgPSAoaXRlbS5ndWlkYW5jZSB8fCBcIlwiKS50cmltKCk7XG4gIFxuICAvLyBJRCBEaW1lbnNpb24gKDE1JSB3ZWlnaHQpXG4gIGNvbnN0IGlkQ2hlY2tzOiBTY29yaW5nQ2hlY2tSZXN1bHRbXSA9IFtcbiAgICBldmFsSWRTdHJ1Y3R1cmVkKGlkKSxcbiAgICBldmFsSWRMZW5ndGgoaWQpLFxuICAgIGV2YWxJZFVuaXF1ZW5lc3MoaWQpXG4gIF07XG4gIGNvbnN0IGlkRGltID0gYWdncmVnYXRlRGltZW5zaW9uKFwiaWRfcXVhbGl0eVwiLCBcIkNvbnRyb2wgSUQgUXVhbGl0eVwiLCAwLjE1LCBpZENoZWNrcyk7XG4gIFxuICAvLyBOYW1lIERpbWVuc2lvbiAoMTUlIHdlaWdodClcbiAgY29uc3QgbmFtZUNoZWNrczogU2NvcmluZ0NoZWNrUmVzdWx0W10gPSBbXG4gICAgZXZhbE5hbWVDb25jaXNlKG5hbWUpLFxuICAgIGV2YWxOYW1lQWN0aW9uT3JpZW50ZWQobmFtZSksXG4gICAgZXZhbE5hbWVQdXJwb3NlQ2xhcml0eShuYW1lKSxcbiAgICBldmFsTmFtZVJvbGVOZXV0cmFsKG5hbWUpXG4gIF07XG4gIGNvbnN0IG5hbWVEaW0gPSBhZ2dyZWdhdGVEaW1lbnNpb24oXCJuYW1lX3F1YWxpdHlcIiwgXCJDb250cm9sIE5hbWUgUXVhbGl0eVwiLCAwLjE1LCBuYW1lQ2hlY2tzKTtcbiAgXG4gIC8vIERlc2NyaXB0aW9uIERpbWVuc2lvbiAoMzAlIHdlaWdodClcbiAgY29uc3QgZGVzY0NoZWNrczogU2NvcmluZ0NoZWNrUmVzdWx0W10gPSBbXG4gICAgZXZhbERlc2NQcmVzZW50VGVuc2UoZGVzYyksXG4gICAgZXZhbERlc2NQYXNzaXZlVm9pY2UoZGVzYyksXG4gICAgZXZhbERlc2NOb01vZGFsVmVyYnMoZGVzYyksXG4gICAgZXZhbERlc2NTaW5nbGVPYmplY3RpdmUoZGVzYyksXG4gICAgZXZhbERlc2NOb1N0ZXBzKGRlc2MpLFxuICAgIGV2YWxEZXNjV29yZENvdW50KGRlc2MpLFxuICAgIGV2YWxEZXNjU3RhbmRhbG9uZUNsYXJpdHkoZGVzYylcbiAgXTtcbiAgY29uc3QgZGVzY0RpbSA9IGFnZ3JlZ2F0ZURpbWVuc2lvbihcImRlc2NyaXB0aW9uX3F1YWxpdHlcIiwgXCJEZXNjcmlwdGlvbiBRdWFsaXR5XCIsIDAuMzAsIGRlc2NDaGVja3MpO1xuICBcbiAgLy8gR3VpZGFuY2UgRGltZW5zaW9uICg0MCUgd2VpZ2h0KVxuICBjb25zdCBndWlkQ2hlY2tzOiBTY29yaW5nQ2hlY2tSZXN1bHRbXSA9IFtcbiAgICBldmFsR3VpZGFuY2VQcmVhbWJsZShndWlkKSxcbiAgICBldmFsR3VpZGFuY2VTdHJ1Y3R1cmVkU3RlcHMoZ3VpZCksXG4gICAgZXZhbEd1aWRhbmNlQWN0aW9uYWJsZShndWlkKSxcbiAgICBldmFsR3VpZGFuY2VQcmVzZW50QWN0aXZlKGd1aWQpLFxuICAgIGV2YWxHdWlkYW5jZVRlY2hBZ25vc3RpYyhndWlkKSxcbiAgICBldmFsR3VpZGFuY2VSb2xlTmV1dHJhbChndWlkKSxcbiAgICBldmFsR3VpZGFuY2VOb0phcmdvbihndWlkKVxuICBdO1xuICBjb25zdCBndWlkRGltID0gYWdncmVnYXRlRGltZW5zaW9uKFwiZ3VpZGFuY2VfcXVhbGl0eVwiLCBcIkd1aWRhbmNlIFF1YWxpdHlcIiwgMC40MCwgZ3VpZENoZWNrcyk7XG4gIC8vIENhbGN1bGF0ZSB0b3RhbCBzY29yZVxuICBjb25zdCB0b3RhbCA9IE1hdGgucm91bmQoXG4gICAgaWREaW0uc2NvcmUgKiAwLjE1ICtcbiAgICBuYW1lRGltLnNjb3JlICogMC4xNSArXG4gICAgZGVzY0RpbS5zY29yZSAqIDAuMzAgK1xuICAgIGd1aWREaW0uc2NvcmUgKiAwLjQwXG4gICk7XG4gIFxuICAvLyBDaGVjayBmb3IgY3JpdGljYWwgZmFpbHVyZXMgKGFueSBjaGVjayB3aXRoIG1heCA+PSAxNSB0aGF0IGhhcyBzdGF0dXMgRkFJTClcbiAgY29uc3QgY3JpdGljYWxGYWlsID0gW2lkRGltLCBuYW1lRGltLCBkZXNjRGltLCBndWlkRGltXS5zb21lKGRpbSA9PlxuICAgIGRpbS5jaGVja3Muc29tZShjaGVjayA9PiBjaGVjay5zdGF0dXMgPT09IFwiRkFJTFwiICYmIGNoZWNrLm1heCA+PSAxNSlcbiAgKTtcbiAgXG4gIC8vIERldGVybWluZSB2ZXJkaWN0XG4gIGxldCB2ZXJkaWN0OiBcInBhc3NcIiB8IFwicGFydGlhbFwiIHwgXCJmYWlsXCI7XG4gIGlmIChjcml0aWNhbEZhaWwpIHtcbiAgICB2ZXJkaWN0ID0gXCJmYWlsXCI7XG4gIH0gZWxzZSBpZiAodG90YWwgPj0gKHNwZWMuc2NvcmluZy50aHJlc2hvbGRzLnBhc3MgfHwgODApKSB7XG4gICAgdmVyZGljdCA9IFwicGFzc1wiO1xuICB9IGVsc2UgaWYgKHRvdGFsID49IChzcGVjLnNjb3JpbmcudGhyZXNob2xkcy5wYXJ0aWFsIHx8IDYwKSkge1xuICAgIHZlcmRpY3QgPSBcInBhcnRpYWxcIjtcbiAgfSBlbHNlIHtcbiAgICB2ZXJkaWN0ID0gXCJmYWlsXCI7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogc3BlYy5tZXRhLnZlcnNpb24gfHwgXCJ2MVwiLFxuICAgIHZlcmRpY3QsXG4gICAgdG90YWw6IHtcbiAgICAgIHNjb3JlOiB0b3RhbCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgZm9ybXVsYTogXCJUT1RBTCA9IDAuMTUqSUQgKyAwLjE1Kk5BTUUgKyAwLjMwKkRFU0MgKyAwLjQwKkdVSURBTkNFXCIsXG4gICAgICB3ZWlnaHRzOiB7XG4gICAgICAgIGlkOiAwLjE1LFxuICAgICAgICBuYW1lOiAwLjE1LFxuICAgICAgICBkZXNjcmlwdGlvbjogMC4zMCxcbiAgICAgICAgZ3VpZGFuY2U6IDAuNDBcbiAgICAgIH0sXG4gICAgICBnYXRlZF9mYWlsOiBjcml0aWNhbEZhaWxcbiAgICB9LFxuICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgIGlkX3F1YWxpdHk6IGlkRGltLFxuICAgICAgbmFtZV9xdWFsaXR5OiBuYW1lRGltLFxuICAgICAgZGVzY3JpcHRpb25fcXVhbGl0eTogZGVzY0RpbSxcbiAgICAgIGd1aWRhbmNlX3F1YWxpdHk6IGd1aWREaW1cbiAgICB9LFxuICAgIG1lc3NhZ2VzOiBidWlsZE1lc3NhZ2VzKGlkRGltLCBuYW1lRGltLCBkZXNjRGltLCBndWlkRGltKSxcbiAgICBzdWdnZXN0aW9uczogYnVpbGRTdWdnZXN0aW9ucyhpZERpbSwgbmFtZURpbSwgZGVzY0RpbSwgZ3VpZERpbSlcbiAgfTtcbn0iXSwibmFtZXMiOlsiY29udHJvbHNTcGVjSnNvbiIsInR5cGUiLCJzcGVjIiwiZGVkdXBlIiwiYXJyIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImxvb2tzU3RydWN0dXJlZCIsInRleHQiLCJ0ZXN0IiwiY291bnRTZW50ZW5jZXMiLCJzcGxpdCIsInMiLCJ0cmltIiwibGVuZ3RoIiwiZXh0cmFjdFN0ZXBzIiwic3RlcHMiLCJsaW5lcyIsImxpbmUiLCJwdXNoIiwicGF0dGVybiIsIm1hdGNoIiwiZXhlYyIsInN0ZXBUZXh0IiwiTU9EQUxfVkVSQlMiLCJWRU5ET1JfTkFNRVMiLCJKQVJHT05fV09SRFMiLCJST0xFX1NQRUNJRklDIiwiRElSRUNUSVZFX1ZFUkJTIiwiUFJFU0VOVF9URU5TRV9JTkRJQ0FUT1JTIiwiUEFTU0lWRV9WT0lDRV9JTkRJQ0FUT1JTIiwiQUNUSU9OX1dPUkRTIiwiZXZhbElkU3RydWN0dXJlZCIsImlkIiwiaGFzU2VwYXJhdG9yIiwiaW5jbHVkZXMiLCJwb2ludHMiLCJ2aW9sYXRpb25zIiwidW5kZWZpbmVkIiwibGFiZWwiLCJtYXgiLCJzdGF0dXMiLCJub3RlcyIsImV2YWxJZExlbmd0aCIsImxlbiIsIndpdGhpbkJvdW5kcyIsInJ1bGVzIiwibWF4X2xlbmd0aCIsImV2YWxJZFVuaXF1ZW5lc3MiLCJoYXNDb250ZW50IiwiZXZhbE5hbWVDb25jaXNlIiwibmFtZSIsIndvcmRzIiwibWF4V29yZHMiLCJjb25jaXNlX21heF93b3JkcyIsImV2YWxOYW1lQWN0aW9uT3JpZW50ZWQiLCJoYXNBY3Rpb25Xb3JkIiwiaXNWYWd1ZSIsIk1hdGgiLCJldmFsTmFtZVB1cnBvc2VDbGFyaXR5IiwidG9vU2hvcnQiLCJ0b29HZW5lcmljIiwiZXZhbE5hbWVSb2xlTmV1dHJhbCIsImhhc1JvbGVSZWYiLCJldmFsRGVzY1ByZXNlbnRUZW5zZSIsImRlc2MiLCJoYXNQcmVzZW50VGVuc2UiLCJoYXNGdXR1cmVUZW5zZSIsImV2YWxEZXNjUGFzc2l2ZVZvaWNlIiwiaGFzUGFzc2l2ZSIsImhhc0FjdGl2ZURpcmVjdGl2ZSIsImV2YWxEZXNjTm9Nb2RhbFZlcmJzIiwiaGFzTW9kYWwiLCJldmFsRGVzY1NpbmdsZU9iamVjdGl2ZSIsImhhc011bHRpcGxlQW5kcyIsImhhc09yQ2xhdXNlcyIsIm91dGNvbWVTdGF0ZW1lbnRzIiwibXVsdGlwbGVPdXRjb21lcyIsImV2YWxEZXNjTm9TdGVwcyIsImhhc0xpc3RNYXJrZXJzIiwiaGFzSW1wbGVtZW50YXRpb25Xb3JkcyIsImhhc1N0ZXBzIiwiZXZhbERlc2NXb3JkQ291bnQiLCJtaW4iLCJldmFsRGVzY1N0YW5kYWxvbmVDbGFyaXR5IiwiaGFzVmFndWVUZXJtcyIsImFjcm9ueW1QYXR0ZXJuIiwiYWNyb255bXMiLCJ1bmV4cGFuZGVkQWNyb255bXMiLCJhY3JvbnltIiwiZXhwYW5kZWRBZnRlciIsIlJlZ0V4cCIsImV4cGFuZGVkQmVmb3JlIiwiZXZhbEd1aWRhbmNlUHJlYW1ibGUiLCJndWlkYW5jZSIsImwiLCJmaXJzdExpbmUiLCJzdGFydHNXaXRoTGlzdCIsInN0YXJ0c1dpdGhEaXJlY3RpdmUiLCJwcmVhbWJsZU1hdGNoIiwicHJlYW1ibGUiLCJzdWJzdHJpbmciLCJoYXNPYmplY3RpdmUiLCJoYXNSYXRpb25hbGUiLCJwcmVhbWJsZVdvcmRzIiwiaGFzU3Vic3RhbnRpYWxQcmVhbWJsZSIsImV2YWxHdWlkYW5jZVN0cnVjdHVyZWRTdGVwcyIsImhhc1N0cnVjdHVyZSIsInN0ZXBDb3VudCIsInN0ZXBzX21pbiIsInN0ZXBzX21heCIsImV2YWxHdWlkYW5jZUFjdGlvbmFibGUiLCJhY3Rpb25hYmxlU3RlcHMiLCJzdGVwIiwicmVwbGFjZSIsImZpcnN0V29yZCIsImlzQ2FwaXRhbGl6ZWQiLCJub3RNb2RhbE9yQXJ0aWNsZSIsImxvbmdFbm91Z2giLCJyYXRpbyIsInJvdW5kIiwiYWN0aW9uVmVyYnMiLCJtYXRjaGVzIiwiYWN0aW9uVmVyYkNvdW50IiwiZXZhbEd1aWRhbmNlUHJlc2VudEFjdGl2ZSIsInByZXNlbnRJbXBlcmF0aXZlcyIsImhhc1Bhc3RUZW5zZSIsImV2YWxHdWlkYW5jZVRlY2hBZ25vc3RpYyIsInZlbmRvck1hdGNoZXMiLCJoYXNWZW5kb3IiLCJ1bmlxdWVWZW5kb3JzIiwibWFwIiwidiIsInRvTG93ZXJDYXNlIiwidmVuZG9yTGlzdCIsImpvaW4iLCJldmFsR3VpZGFuY2VSb2xlTmV1dHJhbCIsImV2YWxHdWlkYW5jZU5vSmFyZ29uIiwiaGFzSmFyZ29uIiwiamFyZ29uIiwiYWdncmVnYXRlRGltZW5zaW9uIiwia2V5Iiwid2VpZ2h0IiwiY2hlY2tzIiwidG90YWxNYXgiLCJyZWR1Y2UiLCJzdW0iLCJjIiwidG90YWxQb2ludHMiLCJzY29yZSIsImJ1aWxkTWVzc2FnZXMiLCJkaW1zIiwibXNncyIsImRpbSIsImNoZWNrIiwibGV2ZWwiLCJzbGljZSIsImJ1aWxkU3VnZ2VzdGlvbnMiLCJzdWdnZXN0aW9ucyIsImFkZCIsImZvckVhY2giLCJzY29yZUNvbnRyb2wiLCJpdGVtIiwiZGVzY3JpcHRpb24iLCJndWlkIiwiaWRDaGVja3MiLCJpZERpbSIsIm5hbWVDaGVja3MiLCJuYW1lRGltIiwiZGVzY0NoZWNrcyIsImRlc2NEaW0iLCJndWlkQ2hlY2tzIiwiZ3VpZERpbSIsInRvdGFsIiwiY3JpdGljYWxGYWlsIiwic29tZSIsInZlcmRpY3QiLCJzY29yaW5nIiwidGhyZXNob2xkcyIsInBhc3MiLCJwYXJ0aWFsIiwidmVyc2lvbiIsIm1ldGEiLCJmb3JtdWxhIiwid2VpZ2h0cyIsImdhdGVkX2ZhaWwiLCJkaW1lbnNpb25zIiwiaWRfcXVhbGl0eSIsIm5hbWVfcXVhbGl0eSIsImRlc2NyaXB0aW9uX3F1YWxpdHkiLCJndWlkYW5jZV9xdWFsaXR5IiwibWVzc2FnZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./scorer/controls.ts\n");

/***/ }),

/***/ "(rsc)/./specs/controls_standard.v1.json":
/*!*****************************************!*\
  !*** ./specs/controls_standard.v1.json ***!
  \*****************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"meta":{"name":"GRC — Controls","version":"v1","description":"Deterministic rules for Control authoring: ID, Name, Description, Guidance (preamble → steps)."},"rules":{"id":{"required":true,"unique_within_framework":true,"structured":true,"separator":".","max_length":24},"name":{"required":true,"concise_max_words":12,"purpose_clarity":true,"action_or_specific":true,"role_neutral":true,"avoid_redundant_framework_name":true},"description":{"required":true,"present_tense":true,"passive_voice":true,"single_objective":true,"no_steps":true,"role_neutral":true,"avoid_modal_verbs":["should","could","may","might"],"min_words":25,"max_words":120,"standalone_clarity":true},"guidance":{"required":true,"preamble_required":true,"preamble_must_cover":["objective_what","rationale_why"],"preamble_max_words":60,"structured_steps_required":true,"steps_min":2,"steps_max":8,"steps_must_be_actionable":true,"steps_present_tense":true,"steps_active_voice":true,"technology_agnostic":true,"role_neutral":true,"avoid_vendor_names":true}},"scoring":{"dimensions":[{"key":"id_quality","weight":0.15,"checks":["required","unique_within_framework","structured","max_length_ok"]},{"key":"name_quality","weight":0.15,"checks":["concise_max_words","purpose_clarity","action_or_specific","role_neutral","no_framework_redundancy"]},{"key":"description_quality","weight":0.3,"checks":["present_tense","passive_voice","single_objective","no_steps","role_neutral","no_modal_verbs","within_word_bounds","standalone_clarity"]},{"key":"guidance_quality","weight":0.4,"checks":["preamble_required","preamble_covers_objective_rationale","preamble_within_word_bound","structured_steps_required","steps_min_max_ok","steps_actionable","steps_present_active","technology_agnostic","role_neutral","no_vendor_names"]}],"thresholds":{"pass":80,"partial":60}},"detectors":{"description_contains_steps":{"trigger":"description has step markers","action":"warn","suggestion_key":"move_steps_to_guidance"},"guidance_missing_structure":{"trigger":"no bullets/numbering in guidance","action":"warn","suggestion_key":"structure_guidance_steps"},"guidance_missing_preamble":{"trigger":"guidance starts with steps","action":"warn","suggestion_key":"add_preamble_what_why"}},"suggestions":[{"key":"move_steps_to_guidance","message":"Control Description must describe the outcome, not the steps. Move implementation steps to Guidance."},{"key":"structure_guidance_steps","message":"Guidance should be structured as 2–8 clear, actionable steps."},{"key":"add_preamble_what_why","message":"Begin Guidance with a brief preamble explaining the objective (what) and rationale (why), then list steps."}],"cadence_policy":{"soft_warning_on_fixed_cadence":true,"no_score_penalty":true,"suppression_if_text_mentions_clause":true,"warning_message":"A fixed cadence was detected (e.g., \'12 months\' or \'quarterly\'). Unless required by a law/standard, prefer flexible wording such as \'at regular intervals\' or \'for a period aligned to risk and regulatory requirements\'."}}');

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcontrols%2Fscore%2Froute&page=%2Fapi%2Fcontrols%2Fscore%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcontrols%2Fscore%2Froute.ts&appDir=%2Fworkspaces%2Fgrc-content-validator%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fworkspaces%2Fgrc-content-validator&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();